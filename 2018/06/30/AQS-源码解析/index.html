<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="摘要,基于CLH的变体队列同步器">
    

    <!--Author-->
    
        <meta name="author" content="ZouFeng">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="AQS 源码解析"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="摘要,基于CLH的变体队列同步器" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="zoufeng_blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>AQS 源码解析 - zoufeng_blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/06/30/AQS-源码解析/">
                AQS 源码解析
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-06-30</span>
            
            
            
                <span class="category">
                    <a href="/categories/j-u-c/">j.u.c</a>
                </span>
            
        </div>
    </div>
	
	<div class="entry" style="position:fixed;left:10px" >
			<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:block">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
			</p>
		<div id="toc-article" class="toc-article" style="display:none">
			<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">x</span>
			<strong class="toc-title">文章目录</strong>
			<ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一、引言"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、引言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#与synchronizer对比"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">与synchronizer对比</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#synchronizer："><span class="post-toc-number">1.2.</span> <span class="post-toc-text">synchronizer：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AQS："><span class="post-toc-number">1.3.</span> <span class="post-toc-text">AQS：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二、AQS原理"><span class="post-toc-number">2.</span> <span class="post-toc-text">二、AQS原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CLH-lock"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">CLH lock</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MCS-lock"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">MCS lock</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#为什么采用CLH"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">为什么采用CLH</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AQS对CLH的改动"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">AQS对CLH的改动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1、加强对队列的管控"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">1、加强对队列的管控</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2、阻塞而不是自旋"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">2、阻塞而不是自旋</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三、AQS两种模式"><span class="post-toc-number">3.</span> <span class="post-toc-text">三、AQS两种模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-共享模式-SHARED"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1.共享模式 SHARED</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#acquireShared-源码解析"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">acquireShared()源码解析</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#doReleaseShared"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">doReleaseShared()</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-独占模式-MUTEX"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">2.独占模式 MUTEX</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#acquire"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">acquire()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#release"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">release()</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四、ConditionObject"><span class="post-toc-number">4.</span> <span class="post-toc-text">四、ConditionObject</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Object的wait-和notify"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Object的wait()和notify()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Condition的await-和signal"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Condition的await()和signal()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#await"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">await()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#signal"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">signal()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五、AQS的响应中断"><span class="post-toc-number">5.</span> <span class="post-toc-text">五、AQS的响应中断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#六、引用"><span class="post-toc-number">6.</span> <span class="post-toc-text">六、引用</span></a></li></ol>
		</div>
		<script type="text/javascript">
			function showToc(){
				var toc_article = document.getElementById("toc-article");
				var show_toc_btn = document.getElementById("show-toc-btn");
				toc_article.setAttribute("style","display:block");
				show_toc_btn.setAttribute("style","display:none");
			};
			function showBtn(){
				var toc_article = document.getElementById("toc-article");
				var show_toc_btn = document.getElementById("show-toc-btn");
				toc_article.setAttribute("style","display:none");
				show_toc_btn.setAttribute("style","display:block");
			};
		</script>
	
    </div>
	
	
	<!-- 文章目录
	<div class="entry" style="position:fixed;right:10px" >
		<ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一、引言"><span class="post-toc-number">1.</span> <span class="post-toc-text">一、引言</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#与synchronizer对比"><span class="post-toc-number">1.1.</span> <span class="post-toc-text">与synchronizer对比</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#synchronizer："><span class="post-toc-number">1.2.</span> <span class="post-toc-text">synchronizer：</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AQS："><span class="post-toc-number">1.3.</span> <span class="post-toc-text">AQS：</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#二、AQS原理"><span class="post-toc-number">2.</span> <span class="post-toc-text">二、AQS原理</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#CLH-lock"><span class="post-toc-number">2.1.</span> <span class="post-toc-text">CLH lock</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#MCS-lock"><span class="post-toc-number">2.2.</span> <span class="post-toc-text">MCS lock</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#为什么采用CLH"><span class="post-toc-number">2.3.</span> <span class="post-toc-text">为什么采用CLH</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#AQS对CLH的改动"><span class="post-toc-number">2.4.</span> <span class="post-toc-text">AQS对CLH的改动</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1、加强对队列的管控"><span class="post-toc-number">2.4.1.</span> <span class="post-toc-text">1、加强对队列的管控</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2、阻塞而不是自旋"><span class="post-toc-number">2.4.2.</span> <span class="post-toc-text">2、阻塞而不是自旋</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#三、AQS两种模式"><span class="post-toc-number">3.</span> <span class="post-toc-text">三、AQS两种模式</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#1-共享模式-SHARED"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">1.共享模式 SHARED</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#acquireShared-源码解析"><span class="post-toc-number">3.1.1.</span> <span class="post-toc-text">acquireShared()源码解析</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#doReleaseShared"><span class="post-toc-number">3.1.2.</span> <span class="post-toc-text">doReleaseShared()</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#2-独占模式-MUTEX"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">2.独占模式 MUTEX</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#acquire"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">acquire()</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#release"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">release()</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#四、ConditionObject"><span class="post-toc-number">4.</span> <span class="post-toc-text">四、ConditionObject</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Object的wait-和notify"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">Object的wait()和notify()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#Condition的await-和signal"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">Condition的await()和signal()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#await"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">await()</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#signal"><span class="post-toc-number">4.4.</span> <span class="post-toc-text">signal()</span></a></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#五、AQS的响应中断"><span class="post-toc-number">5.</span> <span class="post-toc-text">五、AQS的响应中断</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#六、引用"><span class="post-toc-number">6.</span> <span class="post-toc-text">六、引用</span></a></li></ol>
    </div> -->

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><blockquote>
<p> <strong>AQS(AbstractQueuedSynchronizer):  </strong>JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架<br><a id="more"></a></p>
</blockquote>
<h4 id="与synchronizer对比"><a href="#与synchronizer对比" class="headerlink" title="与synchronizer对比"></a>与synchronizer对比</h4><h4 id="synchronizer："><a href="#synchronizer：" class="headerlink" title="synchronizer："></a>synchronizer：</h4><p><strong>优点：</strong>可以花最小的空间开销创建锁（因为每个JAVA对象或者类都可以作为锁使用）和最少的时间开销获得锁（单线程可以在最短时间内获得锁）。线程同步越来越多地被用在多处理器上<br><strong>缺点：</strong>在高并发的情况下，synchronizer表现一般，而且不支持任何公平策略。</p>
<p>于是从JAVA 5开始在java.util.concurrent包中引入了有别于Synchronized的同步框架AQS。</p>
<h4 id="AQS："><a href="#AQS：" class="headerlink" title="AQS："></a>AQS：</h4><p><strong>优点：</strong> 提高了扩展性，用户可自定义同步类、提高吞吐量、提供公平策略及响应中断。<br><strong>缺点：</strong> 增加了空间开销</p>
<h3 id="二、AQS原理"><a href="#二、AQS原理" class="headerlink" title="二、AQS原理"></a>二、AQS原理</h3><p>　　同步框架最重要的是要有一个同步队列，在这里被严格限制为FIFO队列，因此这个同步框架不支持基于优先级的同步策略。</p>
<p>　　队列锁的优点是：进出队快，无锁，畅通无阻（即使在有竞争的情况下，总有一个线程总是能够很快插入到队尾）；检查是否有线程在等待也是很容易的（只需要检查头尾指针是否相同）。</p>
<p>　　而非阻塞队列只有两个可供选择：<strong>CLH队列锁</strong>和<strong>MCS队列锁</strong>。</p>
<h4 id="CLH-lock"><a href="#CLH-lock" class="headerlink" title="CLH lock"></a>CLH lock</h4><blockquote>
<p>CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁. 申请线程只在<strong>前驱节点的本地变量上自旋</strong>，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>; <span class="comment">// 默认是在等待锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater</span><br><span class="line">            .newUpdater(CLHLock.class, CLHNode.class, <span class="string">"tail"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(CLHNode currentThreadCLHNode)</span> </span>&#123;</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, currentThreadCLHNode); <span class="comment">//"tail" 值设置成currentThreadCLHNode</span></span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;<span class="comment">//前面节点在等待锁,说明已有线程占用了锁，进入自旋</span></span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(CLHNode currentThreadCLHNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, currentThreadCLHNode, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 还有后续线程</span></span><br><span class="line">            currentThreadCLHNode.isLocked = <span class="keyword">false</span>;<span class="comment">// 改变状态，让后续线程结束自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="MCS-lock"><a href="#MCS-lock" class="headerlink" title="MCS lock"></a>MCS lock</h4><blockquote>
<p>MCS锁也是一种基于链表的可扩展、高性能、公平的自旋锁，相对于CLH,申请线程只在<strong>当前节点的本地变量上自旋</strong>，当前节点释放锁后通知后续节点结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销.</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSNode</span> </span>&#123;</span><br><span class="line">        MCSNode next;</span><br><span class="line">        <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>; <span class="comment">// 默认是在等待锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> MCSNode queue;<span class="comment">// 指向最后一个申请锁的MCSNode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater</span><br><span class="line">            .newUpdater(MCSLock.class, MCSNode.class, <span class="string">"queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(MCSNode currentThreadMcsNode)</span> </span>&#123;</span><br><span class="line">        MCSNode predecessor = UPDATER.getAndSet(<span class="keyword">this</span>, currentThreadMcsNode);<span class="comment">// step 1</span></span><br><span class="line">        <span class="keyword">if</span> (predecessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            predecessor.next = currentThreadMcsNode;<span class="comment">// step 2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (currentThreadMcsNode.isLocked) &#123;<span class="comment">// step 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(MCSNode currentThreadMcsNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UPDATER.get(<span class="keyword">this</span>) == currentThreadMcsNode) &#123;<span class="comment">// 锁拥有者进行释放锁才有意义</span></span><br><span class="line">            <span class="keyword">if</span> (currentThreadMcsNode.next == <span class="keyword">null</span>) &#123;<span class="comment">// 检查是否有人排在自己后面</span></span><br><span class="line">                <span class="keyword">if</span> (UPDATER.compareAndSet(<span class="keyword">this</span>, currentThreadMcsNode, <span class="keyword">null</span>)) &#123;<span class="comment">// step 4</span></span><br><span class="line">                    <span class="comment">// compareAndSet返回true表示确实没有人排在自己后面</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者</span></span><br><span class="line">                    <span class="comment">// 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完</span></span><br><span class="line">                    <span class="keyword">while</span> (currentThreadMcsNode.next == <span class="keyword">null</span>) &#123; <span class="comment">// step 5</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentThreadMcsNode.next.isLocked = <span class="keyword">false</span>;</span><br><span class="line">            currentThreadMcsNode.next = <span class="keyword">null</span>;<span class="comment">// for GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="为什么采用CLH"><a href="#为什么采用CLH" class="headerlink" title="为什么采用CLH"></a>为什么采用CLH</h4><p>　　AQS的锁策略采用的CLH而不是MCS，原因是CLH要比MCS<strong>更适合处理取消和超时，即响应中断</strong>。因为CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</p>
<p>这需要先理解线程的阻塞和等待的概念</p>
<p><strong>阻塞：</strong>当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断。</p>
<p><strong>等待：</strong>当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断。例如调用：Object.wait()、Thread.join()、LockSupport.park()以及等待Lock或Condition。</p>
<blockquote>
<p>  　　虽然synchronized和J.U.C里的Lock都实现锁的功能，但线程进入的状态是不一样的。<strong>synchronized会让线程进入阻塞态</strong>，而J.U.C里的<strong>Lock是用LockSupport.park()/unpark()来实现阻塞/唤醒的，会让线程进入等待态</strong>。但话又说回来，虽然等锁时进入的状态不一样，但被唤醒后又都进入runnable态，从行为效果来看又是一样的。</p>
</blockquote>
<h4 id="AQS对CLH的改动"><a href="#AQS对CLH的改动" class="headerlink" title="AQS对CLH的改动"></a>AQS对CLH的改动</h4><h5 id="1、加强对队列的管控"><a href="#1、加强对队列的管控" class="headerlink" title="1、加强对队列的管控"></a>1、加强对队列的管控</h5><p>　　CLH只有一个tail节点指向next节点,抽象出一个队列.</p>
<p>　　AQS中定义了Node类，每个Node有各自的状态并且维护了一个prev和一个next用以形成队列结构。AQS保存了一个head节点和一个tail节点,可以快速判断队列中是否只有一个节点,减少对内存的操作.</p>
<h5 id="2、阻塞而不是自旋"><a href="#2、阻塞而不是自旋" class="headerlink" title="2、阻塞而不是自旋"></a>2、阻塞而不是自旋</h5><p>　　CLH是轮训前驱节点的状态进行自旋,而AQS是判断前驱节的状态,然后通过LockSupport.park()和LockSupport.unpark()实现线程的阻塞和释放，该类可以响应中断操作，可以设置超时时间等。此机制与Win32内的“消费事件”机制，Linux NPTL线程库的方式类似</p>
<h3 id="三、AQS两种模式"><a href="#三、AQS两种模式" class="headerlink" title="三、AQS两种模式"></a>三、AQS两种模式</h3><p>上面简单的描述了AQS的原理：</p>
<blockquote>
<p>它是一个队列，线程在获取不到锁的情况下会加入队列排队等待，而在队列中只有头的next结点才能获取锁，执行后出队并唤醒后续线程节点。</p>
</blockquote>
<p>总结下其实就是两个动作，<strong>获取锁（acquire）和释放锁(release)</strong>。</p>
<p>在AQS中提供了两种模式的操作</p>
<h4 id="1-共享模式-SHARED"><a href="#1-共享模式-SHARED" class="headerlink" title="1.共享模式 SHARED"></a>1.共享模式 SHARED</h4><p>共享模式是指同一时刻可以有多个线程获取锁，经典的使用场景是信号量和读写锁。<br>这种模式下的geteState（）一般是指返回锁剩下的数量</p>
<h5 id="acquireShared-源码解析"><a href="#acquireShared-源码解析" class="headerlink" title="acquireShared()源码解析"></a>acquireShared()源码解析</h5><p>这里插入一下Node节点的状态，这个状态是下面很多操作的条件，了解这个对源码 理解会清晰很多</p>
<ul>
<li><strong>SIGNAL</strong> = -1; //表示这个结点的继任结点被阻塞了，到时需要通知它</li>
<li><strong>CONDITION</strong> = -2; //表示这个结点在条件队列中，因为等待某个条件而被阻塞</li>
<li><strong>PROPAGATE</strong> = -3; //使用在共享模式头结点有可能处于这种状态，表示锁的下一次获取可以无条件传播</li>
<li>0：//新结点会处于这种状态。</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//step 1 尝试获取共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">//子类实现逻辑，如果剩下的锁数量小于0，当前线程就去队列排队</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//step 2 执行入队的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//step 2.1 加入CLH队列，节点模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//如果当前节点前驱是头结点，则再次尝试获取共享锁</span></span><br><span class="line">                、、【因为只有head的next节点才有资格去申请锁资源】</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">	                    <span class="comment">//step 3 如果获取锁成功，重新设置头结点[节点出队的操作]并传播r个结点释放锁</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据节点的前驱waitstatus的状态，判断后续节点是否需要挂起，</span></span><br><span class="line">                <span class="comment">//如果前驱的waitstus=-1，则使用LockSupport.park()将当期节点的线程挂起</span></span><br><span class="line">                <span class="comment">//如果前驱的waitstus!=-1，则使用CAS将前驱的waitstus设置为-1，接着loop</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)<span class="comment">//如果异常发生，则根据中断标识来取消获取锁的操作</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//step 2.1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line">		<span class="comment">//新建当前线程的节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 队列中有节点时将节点加入尾部</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//队列没有节点时初始化头结点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p><strong>step 2加入队列流程图如下：</strong><br>AQS CLH队列初始状态，head和tail节点都指向mull<br><img src="/img/aqs/aqs_addwaiter_init.png" alt="Image text"><br>加入第一个节点时,head节点初始化new Node(),head.next和tail节点都指向node1<br><img src="/img/aqs/aqs_addwaiter_node1.png" alt="Image text"><br>加入第二个个节点时，node2加入尾部，tail指向他<br><img src="/img/aqs/aqs_addwaiter_node2.png" alt="Image text"></p>
<p>step 3 <code>重新设置头结点并传播节点，这步是节点唯一的出队方式</code>：将dead的next节点设置为新的head结点，并释放节点里的线程引用，这样下个节点就可以等待获取资源执行线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);<span class="comment">//讲当前节点设置为head节点，且释放线程引用</span></span><br><span class="line">        <span class="comment">//如果</span></span><br><span class="line">        <span class="comment">//1.还有资源可以释放(propagete&gt;0)</span></span><br><span class="line">        <span class="comment">//2.头结点为null</span></span><br><span class="line">        <span class="comment">//3.头结点的状态为-1（singal）或是-3(progate)</span></span><br><span class="line">        <span class="comment">//则开始释放他的下一个节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h5><p>释放共享锁的操作很简单，就只是解除head的next节点的线程阻塞，这样这个节点就可以在上面的step 3中出队<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);<span class="comment">//释放head的next节点的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//这里从tail开始，从后往前找到waitstatus&lt;=0节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h4 id="2-独占模式-MUTEX"><a href="#2-独占模式-MUTEX" class="headerlink" title="2.独占模式 MUTEX"></a>2.独占模式 MUTEX</h4><p>独占锁看名字就很清晰，同一时刻只有一个线程可以获取它。</p>
<p>上面分析了共享锁，独占锁就很容易了，因为操作大同小异，只有一点细微的差异。</p>
<h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">先tryacquire判断是都可以获取，获取失败则添加节点到队列尾部（addwaiter（）在前面已经分析了），然后再去获取整个队列</span><br><span class="line">##### acquireQueued()</span><br><span class="line">``` java</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//和共享模式的doAcquireShared基本一致，只是少唤醒后续节点的操作</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>　　这段代码是不是和前面的doAcquireShared()基本一样？区别只是少了setHeadAndPropagate(),因为独占锁只有一个锁，管好自己就行了，so easy。然后再看看他的锁释放</p>
<h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">//这种情况只在head有next节点情况才满足</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure>
<p>　　锁释放也是简单粗暴，只要满足tryRelease的条件（独占锁一般是看重入的state是否降为0），且头结点的不为nul并且不是刚初始化完成的情况下，直接释放head的next节点线程.</p>
<p>这里，AQS的最核心的操作（acquire和release）就分析完了。</p>
<h3 id="四、ConditionObject"><a href="#四、ConditionObject" class="headerlink" title="四、ConditionObject"></a>四、ConditionObject</h3><p>为了提高AQS的易用性，内部还提供了条件锁对象<br>　　可以这样理解，上面的acquire和release相当于synchronizer的monitorenter和monitorexit,这两个方法定义了一个同步区域，而Condition.await()和signal()就相当于Object的wait()和notify()。</p>
<p>这里顺便复习下Object</p>
<h4 id="Object的wait-和notify"><a href="#Object的wait-和notify" class="headerlink" title="Object的wait()和notify()"></a>Object的wait()和notify()</h4><ul>
<li>调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）</li>
<li>调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程</li>
<li>notifyAll()就是唤醒所有等待该对象monitor的线程</li>
</ul>
<p>如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。</p>
<blockquote>
<p>调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；</p>
</blockquote>
<h4 id="Condition的await-和signal"><a href="#Condition的await-和signal" class="headerlink" title="Condition的await()和signal()"></a>Condition的await()和signal()</h4><p>上面已经说了ConditionObject是模拟Object的wait和notify。</p>
<p>这里先不上源码分析，我们可以先思考下自己会怎么去实现这种效果</p>
<p><strong>await的功能需求:</strong></p>
<ul>
<li>1.首先线程要在获取锁的情况下去await</li>
<li>2.释放锁，然后将当前线程转为等待态（我们可以用LockSupport挂起线程）</li>
</ul>
<p><strong>notify的功能需求:</strong></p>
<ul>
<li>1.唤醒等待该Condition对象的某个线程（先不管唤醒是随机还是顺序）</li>
<li>2.被唤醒的线程重新开始和其他线程竞争，抢占锁资源</li>
</ul>
<p>有了前面AQS部分的基础，实现这个的思路还是很简单的：</p>
<ul>
<li>1.await将线程转为等待态的部分可以用一个新的CLH队列去实现线程等待。因为同一个对象可能在多个线程中使用await，这样就有多个线程在等待，所以必须有个队列去管理他们。线程在队列等待，直到节点被唤醒</li>
<li>2.notify唤醒的线程本质上做的也还是一个AQS CLH 队列节点的事，拿到锁就执行，没拿到继续等待</li>
</ul>
<p>这样思路简化后ConditionObject其实就做了两件事，await()前线程挂起，包装成一个节点放到一个Condition CLH队列，然后signal()就是将Condition的等待节点出队，然后放在AQS的CLH队列中</p>
<p>下面可以对照源码验证一下思路</p>
<h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter(); <span class="comment">//当前线程加入Condition CLH 队列</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放当前线程的锁（并清理重入的标记值）</span></span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;<span class="comment">//如果不在AQS CLH队列则直接挂起当前线程，在的话说明已经被唤醒，开始执行业务代码</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();<span class="comment">//清理已经是Cancelled状态的Condition CLH的wait节点</span></span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实加Condition CLH节点方式和AQS CLH队列加节点的方式差不多，就多了个清理Cancelled态节点的判断和操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//这里和AQS CLH的release稍微不同的是他是从第一个节点开始释放，AQS是释放head的next节点</span></span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) <span class="comment">//将first节点加入AQS CLH队列</span></span><br><span class="line">                    &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node p = enq(node); <span class="comment">//节点加入AQS CLH</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<h3 id="五、AQS的响应中断"><a href="#五、AQS的响应中断" class="headerlink" title="五、AQS的响应中断"></a>五、AQS的响应中断</h3><p>其实AQS的响应中断处理还是挺简单的，虽然有很多逻辑去判断中断的状态标识，有些地方还设置了中断状态码去标识。</p>
<p>这里一句话描述AQS的响应中断：<strong>需要响应中断的就throw InterruptedException,不需要响应中断处理的就进行下中断标识的补充，标记线程被中断过了</strong>。两种情况的后续处理看自己的业务需求了</p>
<p>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();<span class="comment">//打个中断标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//发现中断标记则清理标记并抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h3><ul>
<li><a href="http://www.cnblogs.com/waterystone/p/4920007.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920007.html</a></li>
<li><a href="https://blog.csdn.net/iter_zc/article/details/40373881" target="_blank" rel="noopener">https://blog.csdn.net/iter_zc/article/details/40373881</a> </li>
</ul>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/笔记/">#笔记</a> <a href="/tags/j-u-c/">#j.u.c</a> <a href="/tags/tools/">#tools</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/12/19/rxjava碎碎念/">rxjava设计原理</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/09/17/rxjava设计原理/">rxjava设计原理</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/09/09/vertx-circuitBreadker源码解析/">vertx-circuitBreadker源码解析</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/27/vertx-httpserver源码解析/">vertx httpserver源码解析</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/emotion/">emotion</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/j-u-c/">j.u.c</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/jdk/">jdk</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/netty/">netty</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>