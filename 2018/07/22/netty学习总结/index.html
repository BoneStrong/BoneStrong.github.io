<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="云是风的故事，要很轻很轻才行">
    

    <!--Author-->
    
        <meta name="author" content="ZouFeng">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="netty学习总结"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="云是风的故事，要很轻很轻才行" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="zoufeng_blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    <meta name="twitter:card" content="summary" />
    

    <!-- Title -->
    
    <title>netty学习总结 - zoufeng_blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    <link rel="stylesheet" href="/css/style.css">

    <!-- Google Analytics -->
    


</head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/2018/07/22/netty学习总结/">
                netty学习总结
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2018-07-22</span>
            
            
            
                <span class="category">
                    <a href="/categories/netty/">netty</a>
                </span>
            
        </div>
    </div>
	
	<div class="entry" style="position:fixed;left:10px" >
			<p class="show-toc-btn" id="show-toc-btn" onclick="showToc();" style="display:block">
				<span class="btn-bg"></span>
				<span class="btn-text">文章导航</span>
			</p>
		<div id="toc-article" class="toc-article" style="display:none">
			<span id="toc-close" class="toc-close" title="隐藏导航" onclick="showBtn();">x</span>
			<strong class="toc-title">文章目录</strong>
			<ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高性能原因"><span class="post-toc-number">1.</span> <span class="post-toc-text">高性能原因</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-io模型"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">1.io模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-内存池"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">2.内存池</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-线程模型"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">3.线程模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-数据协议"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">4.数据协议</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#源码分析的demo代码"><span class="post-toc-number">2.</span> <span class="post-toc-text">源码分析的demo代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#几个重要的组件"><span class="post-toc-number">3.</span> <span class="post-toc-text">几个重要的组件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#UnSafe"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">UnSafe</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#EventLoopGroup"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">EventLoopGroup</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#EventGroup的线程模型"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">EventGroup的线程模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channel初始化"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">channel初始化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channel注册过程"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">channel注册过程</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#netty工作流程"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">netty工作流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#netty封装的selector事件交互"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">netty封装的selector事件交互</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ChannelPipeline"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">ChannelPipeline</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channelPieple实例初始化"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">channelPieple实例初始化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pipeline里的ChannelInitializer"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">pipeline里的ChannelInitializer</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pipeline执行流程"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">pipeline执行流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ChannelFutrue-ChannelPromise"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">ChannelFutrue |  ChannelPromise</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#netty的channel"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">netty的channel</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channel-的释放"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">channel 的释放</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channelFuture"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">channelFuture</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#GenericFutureListener"><span class="post-toc-number">3.5.4.</span> <span class="post-toc-text">GenericFutureListener</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一些小问题"><span class="post-toc-number">4.</span> <span class="post-toc-text">一些小问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#拆包与粘包"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">拆包与粘包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解决策略"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">解决策略</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考相关"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">参考相关</span></a></li></ol></li></ol>
		</div>
		<script type="text/javascript">
			function showToc(){
				var toc_article = document.getElementById("toc-article");
				var show_toc_btn = document.getElementById("show-toc-btn");
				toc_article.setAttribute("style","display:block");
				show_toc_btn.setAttribute("style","display:none");
			};
			function showBtn(){
				var toc_article = document.getElementById("toc-article");
				var show_toc_btn = document.getElementById("show-toc-btn");
				toc_article.setAttribute("style","display:none");
				show_toc_btn.setAttribute("style","display:block");
			};
		</script>
	
    </div>
	
	
	<!-- 文章目录
	<div class="entry" style="position:fixed;right:10px" >
		<ol class="post-toc"><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#高性能原因"><span class="post-toc-number">1.</span> <span class="post-toc-text">高性能原因</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#1-io模型"><span class="post-toc-number">1.0.1.</span> <span class="post-toc-text">1.io模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#2-内存池"><span class="post-toc-number">1.0.2.</span> <span class="post-toc-text">2.内存池</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#3-线程模型"><span class="post-toc-number">1.0.3.</span> <span class="post-toc-text">3.线程模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#4-数据协议"><span class="post-toc-number">1.0.4.</span> <span class="post-toc-text">4.数据协议</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#源码分析的demo代码"><span class="post-toc-number">2.</span> <span class="post-toc-text">源码分析的demo代码</span></a></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#几个重要的组件"><span class="post-toc-number">3.</span> <span class="post-toc-text">几个重要的组件</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#UnSafe"><span class="post-toc-number">3.1.</span> <span class="post-toc-text">UnSafe</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#EventLoopGroup"><span class="post-toc-number">3.2.</span> <span class="post-toc-text">EventLoopGroup</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#EventGroup的线程模型"><span class="post-toc-number">3.2.1.</span> <span class="post-toc-text">EventGroup的线程模型</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channel初始化"><span class="post-toc-number">3.2.2.</span> <span class="post-toc-text">channel初始化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channel注册过程"><span class="post-toc-number">3.2.3.</span> <span class="post-toc-text">channel注册过程</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#netty工作流程"><span class="post-toc-number">3.3.</span> <span class="post-toc-text">netty工作流程</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#netty封装的selector事件交互"><span class="post-toc-number">3.3.1.</span> <span class="post-toc-text">netty封装的selector事件交互</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ChannelPipeline"><span class="post-toc-number">3.4.</span> <span class="post-toc-text">ChannelPipeline</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channelPieple实例初始化"><span class="post-toc-number">3.4.1.</span> <span class="post-toc-text">channelPieple实例初始化</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pipeline里的ChannelInitializer"><span class="post-toc-number">3.4.2.</span> <span class="post-toc-text">pipeline里的ChannelInitializer</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#pipeline执行流程"><span class="post-toc-number">3.4.3.</span> <span class="post-toc-text">pipeline执行流程</span></a></li></ol></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#ChannelFutrue-ChannelPromise"><span class="post-toc-number">3.5.</span> <span class="post-toc-text">ChannelFutrue |  ChannelPromise</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#netty的channel"><span class="post-toc-number">3.5.1.</span> <span class="post-toc-text">netty的channel</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channel-的释放"><span class="post-toc-number">3.5.2.</span> <span class="post-toc-text">channel 的释放</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#channelFuture"><span class="post-toc-number">3.5.3.</span> <span class="post-toc-text">channelFuture</span></a></li><li class="post-toc-item post-toc-level-5"><a class="post-toc-link" href="#GenericFutureListener"><span class="post-toc-number">3.5.4.</span> <span class="post-toc-text">GenericFutureListener</span></a></li></ol></li></ol></li><li class="post-toc-item post-toc-level-3"><a class="post-toc-link" href="#一些小问题"><span class="post-toc-number">4.</span> <span class="post-toc-text">一些小问题</span></a><ol class="post-toc-child"><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#拆包与粘包"><span class="post-toc-number">4.1.</span> <span class="post-toc-text">拆包与粘包</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#解决策略"><span class="post-toc-number">4.2.</span> <span class="post-toc-text">解决策略</span></a></li><li class="post-toc-item post-toc-level-4"><a class="post-toc-link" href="#参考相关"><span class="post-toc-number">4.3.</span> <span class="post-toc-text">参考相关</span></a></li></ol></li></ol>
    </div> -->

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <p>前段时间在看zuul2.0，相对于1.0是更改了netty的请求方式，还有很多新功能扩展。这段时间也有看拍拍贷内部的rpc框架，虽然是基于springMVC和Fegin http做的，不是基于netty，但是主流的rpc框架大多是由netty实现的，比如dubbo,琢磨自己给他搞成netty的练练手 ，这里就先整理下netty部分的知识。</p>
<blockquote>
<p>本文基于netty-all：4.1.6.Final，本文源码部分不是线性的去描述的，是基于某个问题一段一段的去看的，最后串成了一条线，所以可能有点跳，下次会好好整理一下。</p>
</blockquote>
<a id="more"></a>
<p>为什么选择netty </p>
<blockquote>
<p>高性能，基于jdk nio的<strong>异步非阻塞</strong>框架</p>
</blockquote>
<ul>
<li>同步 ： 相对于IO操作，在同一个时间，只能完成一个操作（JDK NIO，体现在accpet 客户端连接轮询事件时是一个线程操作）</li>
<li>异步 ： 相对于IO操作，在同一个时间，同时完成多个操作（JDK AIO）</li>
<li>阻塞 ： 相对数据操作而言，判断数据有没有准备好，如果没有准备好，则等待完成 如accpet</li>
<li>非阻塞： 相对数据操作而言，不管数据有没有准备好，立即获取一个反馈</li>
</ul>
<p>Bio的阻塞是在accept客户端连接阻塞的，而Nio的阻塞是在事件上阻塞的，不是说Nio是非阻塞的吗（那是对客户端请求来说是非阻塞的），而服务端对获取客户端请求的等待是阻塞的。<br>Nio中（epoll）使用了多路复用器，所以当某个客户端请求来的时候，会把该客户端连接和客户端请求事件保存到 FD事件队列，在程序中轮询select时是对有事件的channel和事件进行了轮询，他的阻塞是在select（）时阻塞的，而客户端不用同步等待服务端消息，服务端获得select（）中的事件后能立马先给客户端返回一个成功消息，将处理后的信息之后再传过去<br>这里简单提下以前的poll和select模式，其实就是selector轮询所有注册的channel是否事件准备ok，相对于epoll模式直接在一个准备就绪队列里获取事件的效率较低。1.7以后windowns也是epoll了好像，反正了解这个事情就好了，不深究了</p>
<p>同步阻塞 BIO<br>同步非阻塞 NIO<br>异步非阻塞 netty 、jdk AIO<br>netty相对于NIO的异步体现在加入了线程池进行操作（accpet客户端连接后轮询事件的操作丢给了线程池）</p>
<h3 id="高性能原因"><a href="#高性能原因" class="headerlink" title="高性能原因"></a>高性能原因</h3><h5 id="1-io模型"><a href="#1-io模型" class="headerlink" title="1.io模型"></a>1.io模型</h5><p>线程池+nio，异步非阻塞</p>
<h5 id="2-内存池"><a href="#2-内存池" class="headerlink" title="2.内存池"></a>2.内存池</h5><p>netty 0copy：</p>
<ul>
<li>1.直接内存缓存区，直接操作系统内存，减少了数据从jvm内存到操作系统内核的数据copy过程</li>
<li>2.netty提供了更强大的ByteBuf,可以组合多个ByteBuffer对象，可以像操作一个Buffer那样对组合的Buffer进行操作，避免了JDK那种需要通过内存copy的方式将几个ByteBuffer合并成一个</li>
<li>netty文件传输采用了transferTo的方法，可以将文件缓冲区的数据直接发送到目标channel，避免了传统的循环write()方式去进行内存copy （本质是jdk nio 的MappedBuffer 操作系统内存映射的方式）</li>
</ul>
<h5 id="3-线程模型"><a href="#3-线程模型" class="headerlink" title="3.线程模型"></a>3.线程模型</h5><p>提供了单线程，单主多从，多主从这三种线程模型,减少线程数量，调高线程利用率</p>
<h5 id="4-数据协议"><a href="#4-数据协议" class="headerlink" title="4.数据协议"></a>4.数据协议</h5><p>netty的ChannelHandler 编码解码为编写自定义协议提供了非常方便的流程管理，可以自定义编写些相对高效的协议</p>
<h3 id="源码分析的demo代码"><a href="#源码分析的demo代码" class="headerlink" title="源码分析的demo代码"></a>源码分析的demo代码</h3><p>一般我们使用netty的时候会有以下模板代码，本文打算以这个作为源码的入口进行分析，打通netty的结构和执行链路<br><em><code>本文大部分是源码分析，比较长，建议使用导航栏跳到看</code></em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">       EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">           b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                   .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());  </span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder()); </span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> MySelfHandler());  </span><br><span class="line">                       &#125;  </span><br><span class="line">                    &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                   .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); </span><br><span class="line">                   </span><br><span class="line">           ChannelFuture f = b.bind(port).sync();</span><br><span class="line">           LOG.info(<span class="string">"HTTP服务已启动，监听端口:"</span> + port);</span><br><span class="line">           f.channel().closeFuture().sync();  </span><br><span class="line">           </span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">           workerGroup.shutdownGracefully();  </span><br><span class="line">           bossGroup.shutdownGracefully();  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="几个重要的组件"><a href="#几个重要的组件" class="headerlink" title="几个重要的组件"></a>几个重要的组件</h3><p>我们知道 JDK nio有三个重要的组件：selector、channel、buffer。<br>Netty对这几个部分做了相应封装及扩展。</p>
<p> Channel –&gt; NioServerSockerChannel/ NioSockerChannel Unsafe ChannelPipeline<br> ByteBuffer –&gt; ByteBuf<br> Selector –&gt; EventLoop EventLoopGroup</p>
<h4 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h4><p>jdk有个Unsafe对象，是对线程，对象字节码，内存的操作。在Netty框架里，它也设置了一个Unsafe对象，此对象封装了Java NIO底层channel的操作细节，相当于一个代理对象。而且在Netty中，每个channel都有一个unsafe对象。</p>
<h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h4><p>封装selector 这部分功能的组件<br>可以先看下它的类图结构<br><img src="/img/middleware/netty/source/netty_nioEventLoopGroup1.png" alt="Image text"><br>可以看到EventLoopGroup本质其实是个线程池Executor<br>从new EventLoopGroup()入口进入源码参考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">"io.netty.eventLoopThreads"</span>, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到一个有趣的点，这个Excutor的线程数默认是2倍的cpu核数，如果手动设置了线程数量，则两者间取最大的。<br>继续跟进他的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.terminatedChildren = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="keyword">this</span>.terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line">       <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               executor = <span class="keyword">new</span> ThreadPerTaskExecutor(<span class="keyword">this</span>.newDefaultThreadFactory());<span class="comment">//这个是单线程的线程池，【暂时和NioEventLoop的thread不是等价的，在singleThreadEventExecutor.doStartThread后，线程池的线程才被赋予eventLoop的thread变量】</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.children = <span class="keyword">new</span> EventExecutor[nThreads];<span class="comment">//看到这里就很清楚的知道EventLoopGroup本质是个单线程的线程池数组</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> j;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">boolean</span> var18 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   var18 = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">this</span>.children[i] = <span class="keyword">this</span>.newChild((Executor)executor, args);</span><br><span class="line">                   success = <span class="keyword">true</span>;</span><br><span class="line">                   var18 = <span class="keyword">false</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, var19);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//省略线程关闭的代码</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                   <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.children[j].shutdownGracefully();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                       EventExecutor e = <span class="keyword">this</span>.children[j];</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">while</span>(!e.isTerminated()) &#123;</span><br><span class="line">                               e.awaitTermination(<span class="number">2147483647L</span>, TimeUnit.SECONDS);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException var22) &#123;</span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.chooser = chooserFactory.newChooser(<span class="keyword">this</span>.children);<span class="comment">//step 2</span></span><br><span class="line">           FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (MultithreadEventExecutorGroup.<span class="keyword">this</span>.terminatedChildren.incrementAndGet() == MultithreadEventExecutorGroup.<span class="keyword">this</span>.children.length) &#123;<span class="comment">//step 1</span></span><br><span class="line">                       MultithreadEventExecutorGroup.<span class="keyword">this</span>.terminationFuture.setSuccess((Object)<span class="keyword">null</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           EventExecutor[] arr$ = <span class="keyword">this</span>.children;</span><br><span class="line">           j = arr$.length;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; j; ++i$) &#123;</span><br><span class="line">               EventExecutor e = arr$[i$];</span><br><span class="line">               e.terminationFuture().addListener(terminationListener);<span class="comment">//为每个线程池添加监听器，完成时操作step 1</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet(<span class="keyword">this</span>.children.length);</span><br><span class="line">           Collections.addAll(childrenSet, <span class="keyword">this</span>.children);</span><br><span class="line">           <span class="keyword">this</span>.readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里有个小点step 2，根据executor数组的长度是否是2的次幂来选择初始化选择器的策略。以前面试的时候还被别人问过，判断一个数是否是2的次幂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (EventExecutorChooser)(isPowerOfTwo(executors.length) ? <span class="keyword">new</span> DefaultEventExecutorChooserFactory.PowerOfTowEventExecutorChooser(executors) : <span class="keyword">new</span> DefaultEventExecutorChooserFactory.GenericEventExecutorChooser(executors));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里就以-5举例<br>0000 0000 0000 0000 0000 0000 0000 0101 5的原码<br>1000 0000 0000 0000 0000 0000 0000 0101 -5的原码<br>0111 1111 1111 1111 1111 1111 1111 1010 -5的反码   （反码+1=补码）<br>0111 1111 1111 1111 1111 1111 1111 1011 -5的补码  （在计算机中，负数以原码的补码形式表达）</p>
<p>5 &amp; -5<br>0000 0000 0000 0000 0000 0000 0000 0101<br>0111 1111 1111 1111 1111 1111 1111 1011  =<br>0000 0000 0000 0000 0000 0000 0000 0001 !=5 所以不是2的次幂</p>
<p>其实还有更快速的方法去判断一个数是否是二的次幂<br>(number &amp; number - 1) == 0<br>将2的幂次方写成二进制形式后，很容易就会发现有一个特点：二进制中只有一个1，并且1后面跟了n个0； 因此问题可以转化为判断1后面是否跟了n个0就可以了。<br>如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。</p>
<p>上面扯远了，继续回到主线，前面知道了EventLoopGroup是一个线程池组，也知道EventLoopGroup是要封装selector的功能，但是现在问题来了，这个Selector在哪呢，现在进入NioEventLoopGroup代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider)args[<span class="number">0</span>], ((SelectStrategyFactory)args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler)args[<span class="number">2</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到在填充线程池组时候，把selectorProvider扔进去了，其实生成的实例是NioEventLoop。然后根据openSelector()生成Selector实例。同时构造方法有扔进去一个线程池，这个线程池是ThreadPerTaskExecutor类型的，线程池已经初始化了一个线程，不过EventLoop的thread变量现在依旧没有初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> AbstractSelector selector;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          selector = <span class="keyword">this</span>.provider.openSelector();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, var7);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> selector;</span><br><span class="line"><span class="comment">//省略大部分代码.....</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p>这样大概知道netty对selector的封装</p>
<h5 id="EventGroup的线程模型"><a href="#EventGroup的线程模型" class="headerlink" title="EventGroup的线程模型"></a>EventGroup的线程模型</h5><p>对netty稍微了解解的都知道，netty有三种线程模型，一般我们使用的是主从模型，类似于nginx的那个一个主进程（netty可多个），下面有多个工作线程。<br>demo代码里有两个NioEventLoopGroup，这两个Group是如何体现这种模型设计呢?<br>现在进入ServerBootstrap 的group()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"childGroup"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这块代码继续跟进去其实没啥意思，简单的说就是ServerBootstrap有两个成员变量group,childGrop,引用了demo代码里的两个Group。下面带着疑问继续看，两个group的线程之间是如何交互的。ServerBootstrap的启动后两个Group肯定是要开始交互了，跟进去看,首先初始化Channel和注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister(); <span class="comment">// NioServerSocketChannel init and Register</span></span><br><span class="line">       <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">       <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123; </span><br><span class="line">           <span class="keyword">return</span> regFuture;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">           ChannelPromise promise = channel.newPromise();</span><br><span class="line">           doBind0(regFuture, channel, localAddress, promise);<span class="comment">//底层调用jdk 的ServerSocketChannel的bind()绑定地址和端口</span></span><br><span class="line">                       <span class="keyword">return</span> promise;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> AbstractBootstrap.PendingRegistrationPromise promise = <span class="keyword">new</span> AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line">           regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   Throwable cause = future.cause();</span><br><span class="line">                   <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       promise.setFailure(cause);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       promise.registered();</span><br><span class="line">                       AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>进入channel的初始化和注册方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = <span class="keyword">this</span>.channelFactory.newChannel();<span class="comment">//反射获取NioServerSocketChannel</span></span><br><span class="line">            <span class="keyword">this</span>.init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture regFuture = <span class="keyword">this</span>.config().group().register(channel);<span class="comment">//初始化完Channel后进行注册</span></span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="channel初始化"><a href="#channel初始化" class="headerlink" title="channel初始化"></a>channel初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">this</span>.options0();</span><br><span class="line">        <span class="keyword">synchronized</span>(options) &#123;</span><br><span class="line">            channel.config().setOptions(options);<span class="comment">//设置ServerBootStrap的配置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = <span class="keyword">this</span>.attrs0();</span><br><span class="line">        <span class="keyword">synchronized</span>(attrs) &#123;</span><br><span class="line">            Iterator i$ = attrs.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!i$.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e = (Entry)i$.next();</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey)e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline p = channel.pipeline();<span class="comment">//取出channel的ChannelPipeline （channel的ChannelPipeline初始化过程在下一节内容）</span></span><br><span class="line">        <span class="keyword">final</span> EventLoopGroup currentChildGroup = <span class="keyword">this</span>.childGroup;</span><br><span class="line">        <span class="keyword">final</span> ChannelHandler currentChildHandler = <span class="keyword">this</span>.childHandler;</span><br><span class="line">        Map var9 = <span class="keyword">this</span>.childOptions;</span><br><span class="line">        <span class="keyword">final</span> Entry[] currentChildOptions;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childOptions) &#123;</span><br><span class="line">            currentChildOptions = (Entry[])<span class="keyword">this</span>.childOptions.entrySet().toArray(newOptionArray(<span class="keyword">this</span>.childOptions.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var9 = <span class="keyword">this</span>.childAttrs;</span><br><span class="line">        <span class="keyword">final</span> Entry[] currentChildAttrs;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childAttrs) &#123;</span><br><span class="line">            currentChildAttrs = (Entry[])<span class="keyword">this</span>.childAttrs.entrySet().toArray(newAttrArray(<span class="keyword">this</span>.childAttrs.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这块是ChildrenHandle加入Pipeline</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="comment">//这里的ch就是Ser</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>channel的初始化没有什么特别需要注意的，主要是做一些channel的配置，比如serverBootStrap对Tcp的配置。还有初始化相应的channelPipeline。后面就是对pipeline添加Handler的操作</p>
<p>不得不说，pipeline加入ChannelHandle的过程被封装的好恶心,中间还加入了各种回调，其实简单的过程就是pipeline 先把个匿名的ChannelInitializer对象加入pipeline链表节点。然后在chanel注册到eventLoop后回调这个匿名对象的init方法，把pipeline的handle加入链表，最后把这个ChannelInitializer从链表中删掉。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initChannel(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.initChannel(ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">                <span class="keyword">this</span>.exceptionCaught(ctx, var6);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.remove(ctx); <span class="comment">//从链表中移除</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="channel注册过程"><a href="#channel注册过程" class="headerlink" title="channel注册过程"></a>channel注册过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.register((ChannelPromise)(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">        promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.isRegistered()) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AbstractChannel.<span class="keyword">this</span>.isCompatible(eventLoop)) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">                <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.register0(promise);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                AbstractUnsafe.<span class="keyword">this</span>.register0(promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">                        AbstractChannel.logger.warn(<span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>, AbstractChannel.<span class="keyword">this</span>, var4);</span><br><span class="line">                        <span class="keyword">this</span>.closeForcibly();</span><br><span class="line">                        AbstractChannel.<span class="keyword">this</span>.closeFuture.setClosed();</span><br><span class="line">                        <span class="keyword">this</span>.safeSetFailure(promise, var4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure>
<p>前面channel初始化完成后执行this.config().group().register(channel)的操作，这个group是指masterEventLoopGroup，这步相当于channel注册到了Selector上。不过现在依旧让人很疑惑，那workEvenLoopGroup是如何执行后面的呢？</p>
<p>下面就继续看看netty是如何接受客户端请求后，将I/O操作分配给workLoopGroup的EventLoop的</p>
<p>Java NIO 是一种 Reactor 模式, 我们通过 selector 来实现 I/O 的多路复用复用. 在一开始时, 服务器端需要监听客户端的连接请求, 我们的NioServerSocketChannel初始化的时候设置了 OP_ACCEPT, 即通知 selector 我们对客户端的连接请求感兴趣.</p>
<p>回看前面channel初始化时有一段pipeline的addLast方法,添加了一个匿名的ChannelInitializer对象，而这个 ChannelInitializer 中添加了一个关键的 ServerBootstrapAcceptor handler.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//注意这个handler ServerBootstrapAcceptor</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br></pre></td></tr></table></figure></p>
<p>查看他的构造函数,终于找到了通向workEventLoopGroup的大门有木有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrapAcceptor(EventLoopGroup childGroup, ChannelHandler childHandler, Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">            <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">            <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel)msg; <span class="comment">//这里保存了一个NioSocketChannel</span></span><br><span class="line">            child.pipeline().addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">this</span>.childHandler&#125;);</span><br><span class="line">            Entry[] arr$ = <span class="keyword">this</span>.childOptions;</span><br><span class="line">            <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i$;</span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">for</span>(i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                e = arr$[i$];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!child.config().setOption((ChannelOption)e.getKey(), e.getValue())) &#123;</span><br><span class="line">                        ServerBootstrap.logger.warn(<span class="string">"Unknown channel option: "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">                    ServerBootstrap.logger.warn(<span class="string">"Failed to set a channel option: "</span> + child, var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr$ = <span class="keyword">this</span>.childAttrs;</span><br><span class="line">            len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                e = arr$[i$];</span><br><span class="line">                child.attr((AttributeKey)e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将NioSocketChannel注册到workEventLoop上面</span></span><br><span class="line">                <span class="keyword">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">                forceClose(child, var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>ServerBootstrapAcceptor 中的 childGroup 是构造此对象是传入的 currentChildGroup, 即我们的 workerGroup, 而 Channel 是一个 NioSocketChannel 的实例, 因此这里的 childGroup.register 就是将 workerGroup 中的摸个 EventLoop 和 NioSocketChannel 关联了. 既然这样, 那么现在的问题是, ServerBootstrapAcceptor.channelRead 方法是怎么被调用的呢? 我们大概可以知道当一个 client 连接到 server 时, Java 底层的 NIO ServerSocketChannel 会有一个 SelectionKey.OP_ACCEPT 就绪事件, 接着就会调用到 NioServerSocketChannel.doReadMessages:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       SocketChannel ch = <span class="keyword">this</span>.javaChannel().accept();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">               buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">           logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ch.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Failed to close a socket."</span>, var5);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p>
<p>在 doReadMessages 中, 通过 javaChannel().accept() 获取到客户端新连接的 SocketChannel, 接着就实例化一个 NioSocketChannel, 并且传入 NioServerSocketChannel 对象(即 this), 由此可知, 我们创建的这个 NioSocketChannel 的父 Channel 就是 NioServerSocketChannel 实例 .<br>接下来就经由 Netty 的 ChannelPipeline 机制, 将读取事件逐级发送到各个 handler 中, 于是就会触发前面我们提到的 ServerBootstrapAcceptor.channelRead 方法啦，细节部分下面流程部分分析。</p>
<h4 id="netty工作流程"><a href="#netty工作流程" class="headerlink" title="netty工作流程"></a>netty工作流程</h4><p>经过上面一大坨的源码跟踪，可以大概捋出来netty的主从EventLoopGroup是怎么交互的了，特地画了一个图<br><img src="/img/middleware/netty/source/netty_workflow1.png" alt="Image text"><br>文字说明一下大概流程：</p>
<ul>
<li>1.ServerBootStrap在bind(port)时，先反射生成一个NioServerSocketChannel<code>（netty封装jdk nio的ServerSocketChannel对象）</code>对象，这个channel对象在构造的过程中会生成一个相应的ChannelPipeline和Unsafe对象。Pepiel添加一个ServerBootstrapAcceptor类型的Handler。</li>
<li>2.NioServerSocketChannel像MasterEventLoopGroup的一个EventLoopGroup<code>（其实是个封装了Selector的单线程池）</code>注册，其实本质上还是是jdk nio包里的ServerSocketChannek向JDk的Selector注册，并监听OP_ACCPECT的事件</li>
<li>3.客户端发起tcp连接请求，NioServerSocketChannel监听到了accpct事件。</li>
<li>4.监听客户端连接后，NioServerSocketChannel通过jdk的ServerSocketChannel生成一个SocketChannel,同时生成一个ChildChannelPipeline和Unsafe对象，ChildChannelPipeline添加ServerBootStrap里设置的ChildHandlers。</li>
<li>5.SocketChannel向WorkEventLoopGroup中的一个EventLoop注册，监听读写事件。</li>
<li>6.执行ChildChannelPipeline的业务handler</li>
</ul>
<p>现在还有一些细节问题不是很清楚，先列出来，后面一个个去弄清楚：</p>
<ul>
<li><code>1.netty封装的Selector事件，这些事件是如何被捕捉，及捕捉之后怎么和Channel交互的</code></li>
<li><code>2.ChannelPipeline是如何调用的他的handler链的</code></li>
</ul>
<h5 id="netty封装的selector事件交互"><a href="#netty封装的selector事件交互" class="headerlink" title="netty封装的selector事件交互"></a>netty封装的selector事件交互</h5><p>我们依旧从服务端的bind()开始,源码调用跟进到ServerBootstrap.init(Channel channel)部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p>
<p>这里我们看到ch.eventLoop().execute(),添加了ServerBootstrapAcceptor，先暂且不管pipel是怎么addLast执行，前面我们源码并没有分析eventLoop到底是怎么execute的，现在进去看看,这里eventLoop是SingleThreadEventExecutor。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">            addTask(task);<span class="comment">//是当前线程在执行，则直接把需要执行的Runnable当做task放进队列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startThread();<span class="comment">//不是当前线程则开始启动线程，然后继把任务丢进队列</span></span><br><span class="line">            addTask(task);</span><br><span class="line">            <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面可以看到eventLoop最终会把Runnable包装成task任务的形式放入自己的队列当中。但是我们要知道这些任务到底是怎么执行的，进入他的startThread()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.get(<span class="keyword">this</span>) == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                doStartThread();<span class="comment">//开始线程并且cas改变线程的状态为ST_STARTED</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();<span class="comment">//这一步特别重要，将executor里的线程赋给了EventLoop的thread变量，确认了执行的线程</span></span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();<span class="comment">//这里就是Eventloop真正的轮询逻辑了</span></span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//省略一些代码</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的这段代码主要就做了两件事，将EventLoopp的thread变量指向Executor里的那个线程，并且让这个线程启动轮询，监听selector的各种事件。进去看看怎么轮询事件的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据是否有任务还有，得出SelectStrategy的状态</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// fallthrough</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        runAllTasks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                    closeAll();</span><br><span class="line">                    <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到线程一直在轮询Select的状态，事件被封装在processSelectedKeys()中，其实看到这个方法命名大概就知道了netty是怎么监听事件了，细节我们继续<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            processSelectedKeysOptimized(selectedKeys.flip());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">(SelectionKey[] selectedKeys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey k = selectedKeys[i];</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            selectedKeys[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Object a = k.attachment();<span class="comment">//从key中拿到注册的channel</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span> (selectedKeys[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    selectedKeys[i] = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                selectAgain();</span><br><span class="line">                selectedKeys = <span class="keyword">this</span>.selectedKeys.flip();</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>selector拿到准备就绪的SelectedKey[]然后循环执行响应的事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        <span class="comment">//省略一些源码..</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;<span class="comment">//这里就是熟悉的jdk nio的事件判断了</span></span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                unsafe.finishConnect();<span class="comment">//netty 客户端连接时的事件回调</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();<span class="comment">//netty 读事件就绪时的事件回调</span></span><br><span class="line">                <span class="keyword">if</span> (!ch.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面的代码和jdk nio逻辑基本一致，就是多了netty自己的事件回调。我们先仔细看看接受客户端连接时，netty是怎么把socketChannel注册到childEventLoop。有打断点跟源码的话其实会看到这里的readyOps=16,代表的接受连接的事件，至于为什么=16，我们可以看SelectKy源码里的值相应设定的事件：</p>
<ul>
<li>public static final int OP_READ = 1 &lt;&lt; 0; 【1】</li>
<li>public static final int OP_WRITE = 1 &lt;&lt; 2; 【4】</li>
<li>public static final int OP_CONNECT = 1 &lt;&lt; 3; 【8】</li>
<li>public static final int OP_ACCEPT = 1 &lt;&lt; 4; 【16】<blockquote>
<p>对于ServerSocketChannel来说，accept是唯一的有效操作，而对于SocketChannel来说，有效操作包括读、写和连接，另外，对于DatagramChannle，只有读写操作是有效的</p>
</blockquote>
</li>
</ul>
<p>进入unsafe.read()，这个时候unsafe是NioMessageChannel，调用的是父类AbstractNioMessageChannel.read()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> AbstractNioMessageChannel.<span class="keyword">this</span>.eventLoop().inEventLoop();</span><br><span class="line"></span><br><span class="line">            ChannelConfig config = AbstractNioMessageChannel.<span class="keyword">this</span>.config();</span><br><span class="line">            ChannelPipeline pipeline = AbstractNioMessageChannel.<span class="keyword">this</span>.pipeline();</span><br><span class="line">            Handle allocHandle = AbstractNioMessageChannel.<span class="keyword">this</span>.unsafe().recvBufAllocHandle();</span><br><span class="line">            allocHandle.reset(config);</span><br><span class="line">            <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">            Throwable exception = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> localRead;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        localRead = AbstractNioMessageChannel.<span class="keyword">this</span>.doReadMessages(<span class="keyword">this</span>.readBuf);<span class="comment">//read() step 1</span></span><br><span class="line">                        <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            closed = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        allocHandle.incMessagesRead(localRead);</span><br><span class="line">                    &#125; <span class="keyword">while</span>(allocHandle.continueReading());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">                    exception = var11;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                localRead = <span class="keyword">this</span>.readBuf.size();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; localRead; ++i) &#123;</span><br><span class="line">                    AbstractNioMessageChannel.<span class="keyword">this</span>.readPending = <span class="keyword">false</span>;</span><br><span class="line">                    pipeline.fireChannelRead(<span class="keyword">this</span>.readBuf.get(i));<span class="comment">//read() step 2 pipel处理读事件I/O</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.readBuf.clear();</span><br><span class="line">                allocHandle.readComplete();</span><br><span class="line">                pipeline.fireChannelReadComplete();<span class="comment">//read() step 3 pipel处理读事件I/O完成时的操作</span></span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    closed = AbstractNioMessageChannel.<span class="keyword">this</span>.closeOnReadError(exception);</span><br><span class="line">                    pipeline.fireExceptionCaught(exception);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                    AbstractNioMessageChannel.<span class="keyword">this</span>.inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (AbstractNioMessageChannel.<span class="keyword">this</span>.isOpen()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.close(<span class="keyword">this</span>.voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!AbstractNioMessageChannel.<span class="keyword">this</span>.readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.removeReadOp();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可看到read()方法开始使用ServerSocketChannel的ChannelPiple，先执行step 1 doReadMessages()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel ch = <span class="keyword">this</span>.javaChannel().accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to close a socket."</span>, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里知道NioServerSocketChannel接受连接本质还是使用了jdk ServerSocketChannel的accept()，生成了一个SocketChannel ,并封装成Netty的NioSocketChannel，指定netty的NioServerSocketChannel为他的父Channel。</p>
<p><code>这里其实疑问点，为什么这里循环两次doMessage，生成了两个NioSocketChannel</code>,先记着</p>
<p>生成NioSocketChannel后，NioServerSocketChannel用开始调用pipeline的ChannelHandle处理read事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>这里开始从头节点执行ChannelRead事件，继续深入调用链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面已经说了next其实是pepel的头节点，((ChannelInboundHandler) handler()).channelRead(this, msg)其实使用的是headContex的重写的channelRead方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>跟进去，又调回AbstractChannelHandlerContext的fireChannelRead<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">        <span class="comment">//从头结点往后找，直到找到inbound类型的Handler，这里其实是NioServerSocketChannel ChannelPipel里添加的ServerBootStrapAcceptor</span></span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>然后执行ServerBootStrapAcceptor的channelRead()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Unknown channel option: "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to set a channel option: "</span> + child, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p>
<p>看到这里不陌生了，我们前面也分析过这段代码，这里就是将NioSocketChannel注册到childEventLoop的Selector上面，然后后面的执行逻辑其实和MasterEventLoop差不多，简单的说就是childEventLoop里的线程也一直轮询注册的NioSocketChannels传递过来的事件(这里也是netty高性能的原因之一，一个eventLoop被多个channel注册)，其实主要是read和write事件,然后回调NioSocketChannel里的ChannelPipeline的ChannelRead/write等方法，链式执行里面的各种handler。</p>
<p>下面来分析下ChannelPipeline的处理流程。</p>
<h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p>channel扩展了功能处理，netty自己为每个channel对应了一个ChannelPieple</p>
<h5 id="channelPieple实例初始化"><a href="#channelPieple实例初始化" class="headerlink" title="channelPieple实例初始化"></a>channelPieple实例初始化</h5><p>签名boosEventLoopGroup反射生成一个NioServerSocketChannel时，看它的构造过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123; <span class="comment">//step 1 无参构造</span></span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.nio.channels.<span class="function">ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel(); <span class="comment">//step 2 生成一个NioServerSocketChannel</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to open a server socket."</span>, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(newSocket(provider));<span class="comment">// step 3  调用有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(java.nio.channels.ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Channel)<span class="keyword">null</span>, channel, <span class="number">16</span>); <span class="comment">//step 4 调用父类方法的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.config = <span class="keyword">new</span> NioServerSocketChannel.NioServerSocketChannelConfig(<span class="keyword">this</span>, <span class="keyword">this</span>.javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里构造器很重要，相当于将jdk的NIO Channel通道封装进入了Netty的Channel通道</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.ch = ch; <span class="comment">//[这里保存jdk的nio serverChannel!!]NioServerSocketChannel是Netty的</span></span><br><span class="line">        <span class="keyword">this</span>.readInterestOp = readInterestOp; <span class="comment">//设置设置ServerSocketChannel关心的事件类型,这里是指只监听OP_ACCPET的事件，因为一开始Selector也只接受这个事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">//设置jdk nio为非阻塞的</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to close a partially initialized socket."</span>, var6);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="keyword">this</span>.newId();</span><br><span class="line">        <span class="keyword">this</span>.unsafe = <span class="keyword">this</span>.newUnsafe();<span class="comment">//每一个channel都有一个折翼的Unsafe</span></span><br><span class="line">        <span class="keyword">this</span>.pipeline = <span class="keyword">this</span>.newChannelPipeline(); <span class="comment">//step5 跟进父类构造函数可以看到 这里初始化了一个ChannelPieple</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123; <span class="comment">//step 6 pipel的构造过程</span></span><br><span class="line">        <span class="keyword">this</span>.channel = (Channel)ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">        <span class="keyword">this</span>.succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, (EventExecutor)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DefaultChannelPipeline.TailContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DefaultChannelPipeline.HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">this</span>.tail.prev = <span class="keyword">this</span>.head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>可以看到ChannelPipeline本质是个双向链表，有AbstractChannelHandlerContext类型的tail和head链表节点。看AbstractChannelHandlerContext的类结构，它本身也是个channelHandle。不过在使用过程中，context的是handler的上下文，相当于handler的容器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, <span class="keyword">this</span>.childExecutor(group), name, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h5 id="pipeline里的ChannelInitializer"><a href="#pipeline里的ChannelInitializer" class="headerlink" title="pipeline里的ChannelInitializer"></a>pipeline里的ChannelInitializer</h5><p>pipeline链路的初始化是基于这个类的，其实这个的初始化还是比较简单，也就不贴netty代码了，贴下执行链路</p>
<ul>
<li>pipeline.addLast(ChannelInitializer)</li>
<li>–&gt;DefaultChannelPipeline.addLast(null, handlers);</li>
<li>–&gt;DefaultChannelPipeline.addLast(null, handlers) –&gt;addLast(EventExecutorGroup group, String name, ChannelHandler handler)</li>
<li>–&gt;addLast0(AbstractChannelHandlerContext newCtx)  ChannelInitializer加入链路</li>
<li>–&gt;callHandlerAdded0(newCtx);</li>
<li>–&gt;ChannelInitializer.handlerAdded(ctx)</li>
<li>–&gt;ChannelInitializer.initChannel(ctx) //最终调用定义的initChannel()方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>这里面也把线程的执行串起来了，netty的工作流程在这里可以说已经通路了</p>
<h5 id="pipeline执行流程"><a href="#pipeline执行流程" class="headerlink" title="pipeline执行流程"></a>pipeline执行流程</h5><p>其实上面的源码分析，很多已经涉及到了pipeline的执行流程，这里就简单回顾下，pipeline的执行始于eventLoop对Seletor事件的回调，然后pipeline根据是出站还是进站事件从头节点到尾节点，或是尾节点到头结点、</p>
<h4 id="ChannelFutrue-ChannelPromise"><a href="#ChannelFutrue-ChannelPromise" class="headerlink" title="ChannelFutrue |  ChannelPromise"></a>ChannelFutrue |  ChannelPromise</h4><h5 id="netty的channel"><a href="#netty的channel" class="headerlink" title="netty的channel"></a>netty的channel</h5><p>这个本来应该放在前面讲的，先不管排版了- -！这部分内容也比较简单，是引用别人总结的<br>Netty的Channel相对于jdk的channel多了些扩展，除了jdk NIO中Channel所包含的网络I/O操作,主动建立/关闭连接,获取双方网络地址的功能外,还包含了Netty框架的功能,例如:获取Channel的EventLoop\Pipeline等。</p>
<ul>
<li>Channel接口是能与一个网络套接字(或组件)进行I/0操作(读取\写入\连接\绑定)的纽带.</li>
<li>通过Channel可以获取连接的状态(是否连接/是否打开),配置通道的参数(设置缓冲区大小等),进行I/O操作</li>
</ul>
<h5 id="channel-的释放"><a href="#channel-的释放" class="headerlink" title="channel 的释放"></a>channel 的释放</h5><p>当Channel完成工作后,需要调用ChannelOutboundInvoker.close()或ChannelOutboundInvoker.close(ChannelPromise)释放所有资源.这样做是为了确保所有资源(文件句柄)都能够得到释放</p>
<h5 id="channelFuture"><a href="#channelFuture" class="headerlink" title="channelFuture"></a>channelFuture</h5><p>channelFuture是为了在异步操作时，获取channel（状态）结果的的扩展<br>ChannelFuture有两种状态:未完成(uncompleted)和完成(completed).<br>当令Channel开始一个I/O操作时,会创建一个新的ChannelFuture去异步完成操作.<br>被创建时的ChannelFuture处于uncompleted状态(非失败,非成功,非取消);一旦ChannelFuture完成I/O操作,ChannelFuture将处于completed状态,结果可能有三种: </p>
<ul>
<li>成功</li>
<li>失败</li>
<li>取消（I/O操作被终止）</li>
</ul>
<p>netty里面关于channelFuture的状态图如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                                    +---------------------------+</span><br><span class="line">                                     | Completed successfully    |</span><br><span class="line">                                     +---------------------------+</span><br><span class="line">                                +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">+--------------------------+    |    |   isSuccess() = <span class="keyword">true</span>      |</span><br><span class="line">|        Uncompleted       |    |    +===========================+</span><br><span class="line">+--------------------------+    |    | Completed with failure    |</span><br><span class="line">|      isDone() = <span class="keyword">false</span>    |    |    +---------------------------+</span><br><span class="line">|   isSuccess() = <span class="keyword">false</span>    |----+----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">| isCancelled() = <span class="keyword">false</span>    |    |    |       cause() = non-<span class="keyword">null</span>  |</span><br><span class="line">|       cause() = <span class="keyword">null</span>     |    |    +===========================+</span><br><span class="line">+--------------------------+    |    | Completed by cancellation |</span><br><span class="line">                                |    +---------------------------+</span><br><span class="line">                                +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">                                     | isCancelled() = <span class="keyword">true</span>      |</span><br><span class="line">                                     +---------------------------+</span><br></pre></td></tr></table></figure></p>
<p>channelFuture和channelPromise的区别简单的说就是一个可以设置返回值，其实两个是成对出现的</p>
<p>还有回调部分的扩展</p>
<h5 id="GenericFutureListener"><a href="#GenericFutureListener" class="headerlink" title="GenericFutureListener"></a>GenericFutureListener</h5><p>虽然可以通过ChannelFuture的get()方法获取异步操作的结果,但完成时间是无法预测的,若不设置超时时间则有可能导致线程长时间被阻塞;若是不能精确的设置超时时间则可能导致I/O操作中断.因此,Netty建议通过GenericFutureListener接口执行异步操作结束后的回调.</p>
<p>netty添加回调的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">     ChannelFuture future = ctx.channel().close();</span><br><span class="line">     future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// Perform post-closure operation</span></span><br><span class="line">             <span class="comment">// ...</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p>
<p>netty中调用监听的部分源码示例:ChannelPromise<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPromise</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelPromise <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addListener(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//super是DefaultPromise</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(listener, <span class="string">"listener"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addListener0(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isDone()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.notifyListeners();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//DefaultPromise来执行回调</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener</span><span class="params">(EventExecutor eventExecutor, Future&lt;?&gt; future, GenericFutureListener&lt;?&gt; listener)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(eventExecutor, <span class="string">"eventExecutor"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(future, <span class="string">"future"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(listener, <span class="string">"listener"</span>);</span><br><span class="line">        notifyListenerWithStackOverFlowProtection(eventExecutor, future, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListenerWithStackOverFlowProtection</span><span class="params">(EventExecutor executor, <span class="keyword">final</span> Future&lt;?&gt; future, <span class="keyword">final</span> GenericFutureListener&lt;?&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(executor.inEventLoop()) &#123;</span><br><span class="line">            InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();</span><br><span class="line">            <span class="keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth();</span><br><span class="line">            <span class="keyword">if</span>(stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;</span><br><span class="line">                threadLocals.setFutureListenerStackDepth(stackDepth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    notifyListener0(future, listener);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    threadLocals.setFutureListenerStackDepth(stackDepth);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DefaultPromise.notifyListener0(future, listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener0</span><span class="params">(Future future, GenericFutureListener l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l.operationComplete(future);<span class="comment">//执行我们定义的回调方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            logger.warn(<span class="string">"An exception was thrown by "</span> + l.getClass().getName() + <span class="string">".operationComplete()"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<p>addListener(GenericFutureListener)是非阻塞的。它会把特定的ChannelFutureListener添加到ChannelFuture中，然后I/O线程会在I/O操作相关的future完成的时候通知监听器。ChannelFutureListener会利于最佳的性能和资源的利用，因为它一点阻塞都没有。然而，如果你不使用基于事件驱动的编程方式，去实现一个后续式的逻辑会变得诡异和难于理解。</p>
<p>具体什么时候执行回调，是在状态改变的时候，比如完成成功时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultPromise</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.setSuccess0(result)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.notifyListeners();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"complete already: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h3><h4 id="拆包与粘包"><a href="#拆包与粘包" class="headerlink" title="拆包与粘包"></a>拆包与粘包</h4><p>tcp是一个二进制字节码流的协议，所谓流就是没有界限的概念。作为传输层并不理解上层协议业务数据的含义，他会根据tcp缓冲区的实际情况进行包的划分，但是在业务上被认为是一个完成的数据包。比如一个数据包被tcp分作多次发送，或是多个数据包封装成一个发送。这就是拆包和粘包</p>
<h4 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h4><ul>
<li>消息定长，比如报文固定1024字节，不够的空格补齐</li>
<li>包尾添加特殊分隔符，比如ftp协议，每条报文结束都添加回车换行符。接收方通过特殊分隔符切分报文</li>
<li>将消息分为消息头额消息体。消息头包含消息体的总长度</li>
<li>自定义应用层协议</li>
</ul>
<blockquote>
<p>netty的编码解码handler就相当于tcp的拆包粘包的过程</p>
</blockquote>
<h4 id="参考相关"><a href="#参考相关" class="headerlink" title="参考相关"></a>参考相关</h4><p><a href="https://segmentfault.com/a/1190000006824196" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006824196</a><br><a href="https://segmentfault.com/a/1190000007283053" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007283053</a><br><a href="https://blog.csdn.net/wbbhao/article/details/78943624" target="_blank" rel="noopener">https://blog.csdn.net/wbbhao/article/details/78943624</a><br><a href="https://blog.csdn.net/wbbhao/article/details/78943567" target="_blank" rel="noopener">https://blog.csdn.net/wbbhao/article/details/78943567</a><br><a href="https://www.jianshu.com/p/d94b6350ddaa（nio各组件）" target="_blank" rel="noopener">https://www.jianshu.com/p/d94b6350ddaa（nio各组件）</a></p>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/笔记/">#笔记</a> <a href="/tags/nio/">#nio</a> <a href="/tags/netty/">#netty</a>
        </div>
    

    <!-- Comments -->
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    This theme was developed by <a href="https://github.com/klugjo">Jonathan Klughertz</a>. The source code is available on Github. Create Websites. Make Magic.
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2018/12/19/rxjava碎碎念/">rxjava设计原理</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/09/17/rxjava设计原理/">rxjava设计原理</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/09/09/vertx-circuitBreadker源码解析/">vertx-circuitBreadker源码解析</a>
            </li>
            
            <li>
                <a class="footer-post" href="/2018/08/27/vertx-httpserver源码解析/">vertx httpserver源码解析</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/emotion/">emotion</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/j-u-c/">j.u.c</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/jdk/">jdk</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/netty/">netty</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a href="https://github.com/klugjo/hexo-theme-alpha-dust">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://twitter.com/?lang=en">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.facebook.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.instagram.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://dribbble.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://plus.google.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-google-plus"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://www.behance.net/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="https://500px.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:test@example.com">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->
<script src="/js/main.js"></script>

<!-- Disqus Comments -->



</body>

</html>