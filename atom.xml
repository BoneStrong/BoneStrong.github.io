<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>zoufeng_blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2018-12-20T02:34:02.357Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>ZouFeng</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>rxjava设计原理</title>
    <link href="http://yoursite.com/2018/12/19/rxjava%E7%A2%8E%E7%A2%8E%E5%BF%B5/"/>
    <id>http://yoursite.com/2018/12/19/rxjava碎碎念/</id>
    <published>2018-12-19T09:29:24.000Z</published>
    <updated>2018-12-20T02:34:02.357Z</updated>
    
    <content type="html"><![CDATA[<p>#rxjava的碎碎念</p><p>##rxjava的设计模型<br>一说到rxjava的设计模式，大家脑海中估计第一个就是观察者模式</p><p>但想想却不大对劲，现在自己捋下</p><p>rxjava分为几个部分，观察源（Observer）</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;#rxjava的碎碎念&lt;/p&gt;
&lt;p&gt;##rxjava的设计模型&lt;br&gt;一说到rxjava的设计模式，大家脑海中估计第一个就是观察者模式&lt;/p&gt;
&lt;p&gt;但想想却不大对劲，现在自己捋下&lt;/p&gt;
&lt;p&gt;rxjava分为几个部分，观察源（Observer）&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>rxjava设计原理</title>
    <link href="http://yoursite.com/2018/09/17/rxjava%E8%AE%BE%E8%AE%A1%E5%8E%9F%E7%90%86/"/>
    <id>http://yoursite.com/2018/09/17/rxjava设计原理/</id>
    <published>2018-09-17T02:29:24.000Z</published>
    <updated>2018-09-27T07:32:02.950Z</updated>
    
    <content type="html"><![CDATA[<h1 id="为什么学习rxjava"><a href="#为什么学习rxjava" class="headerlink" title="为什么学习rxjava"></a>为什么学习rxjava</h1><ul><li>1.它是什么</li><li>2.解决了什么问题</li></ul><h1 id="基本组件"><a href="#基本组件" class="headerlink" title="基本组件"></a>基本组件</h1><blockquote><p><strong>本文简化了源码的各种扩展和兼容，只描述简单的实现原理，方便理解</strong></p></blockquote><p>rxJava主要有三个组件和操作符，了解这些东西的话基本算是入了门。</p><h2 id="Observable"><a href="#Observable" class="headerlink" title="Observable"></a>Observable</h2><p>见名知意，这是一个观察源，供观察者观察的。从他的构造方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Observable</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">final</span> OnSubscribe&lt;T&gt; onSubscribe;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Observable</span><span class="params">(OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.onSubscribe = onSubscribe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> OnSubscribe&lt;T&gt; <span class="title">getOnSubscribe</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> onSubscribe;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Observable&lt;T&gt; <span class="title">create</span><span class="params">(OnSubscribe&lt;T&gt; onSubscribe)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Observable&lt;T&gt;(onSubscribe);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">subscribe</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">        subscriber.onStart();</span><br><span class="line">        onSubscribe.call(subscriber);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="OnSubscribe"><a href="#OnSubscribe" class="headerlink" title="OnSubscribe"></a>OnSubscribe</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">OnSubscribe</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通知订阅者</span></span><br><span class="line"><span class="comment">     *</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> subscriber 订阅者</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">(Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="Subscribe"><a href="#Subscribe" class="headerlink" title="Subscribe"></a>Subscribe</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">Subscriber</span>&lt;<span class="title">T</span>&gt; <span class="keyword">implements</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">Subscriber</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onStart</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="comment">//dosomething</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Observer</span>&lt;<span class="title">T</span>&gt; </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable t)</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T var1)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="rx操作符"><a href="#rx操作符" class="headerlink" title="rx操作符"></a>rx操作符</h1><h2 id="lift"><a href="#lift" class="headerlink" title="lift"></a>lift</h2><p>最基本的操作符，rxjava的各种转换就是基于这个操作符的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Func1</span>&lt;<span class="title">T</span>, <span class="title">R</span>&gt; </span>&#123;</span><br><span class="line">        <span class="function">R <span class="title">call</span><span class="params">(T t)</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Operator</span>&lt;<span class="title">R</span>, <span class="title">T</span>&gt; <span class="keyword">extends</span> <span class="title">Func1</span>&lt;<span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">R</span>&gt;, <span class="title">Subscriber</span>&lt;? <span class="title">super</span> <span class="title">T</span>&gt;&gt; </span>&#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> &lt;R&gt; <span class="function">Observable&lt;R&gt; <span class="title">lift</span><span class="params">(Operator&lt;? extends R, ? <span class="keyword">super</span> T&gt; operator)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(subscriber -&gt; &#123;</span><br><span class="line">            Observable.<span class="keyword">this</span>.subscribe(operator.call(subscriber));</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="defer"><a href="#defer" class="headerlink" title="defer"></a>defer</h2><p>对Observable做一层包装，只在订阅后才开始初始化Observable里面的值,这个没啥好实现的，超级简单</p><h2 id="from"><a href="#from" class="headerlink" title="from"></a>from</h2><h1 id="线程切换"><a href="#线程切换" class="headerlink" title="线程切换"></a>线程切换</h1><p>回顾前面Observable的执行过程，Observable订阅Subscribe后有这么三个执行阶段：</p><ul><li>1.订阅时执行通知前 subscribe.onstart()</li><li>2.通知subscribe但未发射事件前 OnSubscribe.call(subscribe)</li><li>3.发射事件 subscribe.onNext()</li></ul><p>rxJava的线程切换本质上是生成一个代理Observable层，主要是代理2和3两个阶段。</p><p>代理2阶段的话是着重与代理OnSubscribe这个通道。【ObServableOn()生成的代理】</p><p>代理3阶段的话是是代理执行的Subscribe。【subscribeOn()生成的代理】</p><p>给不同的阶段设置不同的执行线程，就是rxjava实现的线程切换了</p><h2 id="SubscribeOn"><a href="#SubscribeOn" class="headerlink" title="SubscribeOn"></a>SubscribeOn</h2><p>将OnSubscribe的执行过程放入指定线程执行（即call()过程），只是第一次有效。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">subscribeOn</span><span class="params">(<span class="keyword">final</span> Scheduler scheduler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line">                scheduler.createWorker().schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        Observable.<span class="keyword">this</span>.onSubscribe.call(subscriber);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="ObservableOn"><a href="#ObservableOn" class="headerlink" title="ObservableOn"></a>ObservableOn</h2><p>将subscribe的执行放入指定线程，可多次切换<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">observeOn</span><span class="params">(<span class="keyword">final</span> Scheduler scheduler)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> Observable.create(<span class="keyword">new</span> OnSubscribe&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">(<span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> T&gt; subscriber)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">final</span> Scheduler.Worker worker = scheduler.createWorker();</span><br><span class="line"></span><br><span class="line">                Observable.<span class="keyword">this</span>.subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;(<span class="string">"proxySubscriber"</span> + System.nanoTime()) &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        worker.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                subscriber.onCompleted();</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(<span class="keyword">final</span> Throwable t)</span> </span>&#123;</span><br><span class="line">                        worker.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                subscriber.onError(t);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(<span class="keyword">final</span> T var1)</span> </span>&#123;</span><br><span class="line">                        worker.schedule(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                subscriber.onNext(var1);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="doOnSubscribe"><a href="#doOnSubscribe" class="headerlink" title="doOnSubscribe"></a>doOnSubscribe</h2><p>一个扩展层，将OnSubscribe的订阅–call之间的过程放入指定线程执行<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//简化了源码实现</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> Observable&lt;T&gt; <span class="title">doOnSubscribe</span><span class="params">(Action0 action0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Observable.create(subscriber -&gt; &#123;</span><br><span class="line">            action0.call();</span><br><span class="line">            Observable.<span class="keyword">this</span>.onSubscribe.call(subscriber);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Action0</span> </span>&#123;</span><br><span class="line">        <span class="function"><span class="keyword">void</span> <span class="title">call</span><span class="params">()</span></span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>结合SubscribeOn可以指定doOnSubscribe的执行线程</p><p>类似的还有doOnTerminate()不过这个是结束时扩展操作</p><h1 id="奇怪的操作符"><a href="#奇怪的操作符" class="headerlink" title="奇怪的操作符"></a>奇怪的操作符</h1><h2 id="single"><a href="#single" class="headerlink" title="single()"></a>single()</h2><p>只在blockingObservable中起作用，保证发射的事件只有一个,配合toFuture用</p><p>本质上是在SubscribeArray发射前判断是否唯一，否则抛出异常<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> &lt;T&gt; <span class="function">Future&lt;T&gt; <span class="title">toFuture</span><span class="params">(Observable&lt;? extends T&gt; that)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> CountDownLatch finished = <span class="keyword">new</span> CountDownLatch(<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">final</span> AtomicReference&lt;T&gt; value = <span class="keyword">new</span> AtomicReference&lt;T&gt;();</span><br><span class="line">        <span class="keyword">final</span> AtomicReference&lt;Throwable&gt; error = <span class="keyword">new</span> AtomicReference&lt;Throwable&gt;();</span><br><span class="line"></span><br><span class="line">        <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">        <span class="keyword">final</span> Subscription s = ((Observable&lt;T&gt;)that).single().subscribe(<span class="keyword">new</span> Subscriber&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onCompleted</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                finished.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onError</span><span class="params">(Throwable e)</span> </span>&#123;</span><br><span class="line">                error.compareAndSet(<span class="keyword">null</span>, e);</span><br><span class="line">                finished.countDown();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onNext</span><span class="params">(T v)</span> </span>&#123;</span><br><span class="line">                <span class="comment">// "single" guarantees there is only one "onNext"</span></span><br><span class="line">                value.set(v);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Future&lt;T&gt;() &#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">private</span> <span class="keyword">volatile</span> <span class="keyword">boolean</span> cancelled;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">cancel</span><span class="params">(<span class="keyword">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (finished.getCount() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                    cancelled = <span class="keyword">true</span>;</span><br><span class="line">                    s.unsubscribe();</span><br><span class="line">                    <span class="comment">// release the latch (a race condition may have already released it by now)</span></span><br><span class="line">                    finished.countDown();</span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// can't cancel</span></span><br><span class="line">                    <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isCancelled</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> cancelled;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">isDone</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                <span class="keyword">return</span> finished.getCount() == <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class="line">                finished.await();</span><br><span class="line">                <span class="keyword">return</span> getValue();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> T <span class="title">get</span><span class="params">(<span class="keyword">long</span> timeout, TimeUnit unit)</span> <span class="keyword">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (finished.await(timeout, unit)) &#123;</span><br><span class="line">                    <span class="keyword">return</span> getValue();</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> TimeoutException(<span class="string">"Timed out after "</span> + unit.toMillis(timeout) + <span class="string">"ms waiting for underlying Observable."</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="function"><span class="keyword">private</span> T <span class="title">getValue</span><span class="params">()</span> <span class="keyword">throws</span> ExecutionException </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> Throwable throwable = error.get();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (throwable != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> ExecutionException(<span class="string">"Observable onError"</span>, throwable);</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (cancelled) &#123;</span><br><span class="line">                    <span class="comment">// Contract of Future.get() requires us to throw this:</span></span><br><span class="line">                    <span class="keyword">throw</span> <span class="keyword">new</span> CancellationException(<span class="string">"Subscription unsubscribed"</span>);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">return</span> value.get();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="range"><a href="#range" class="headerlink" title="range()"></a>range()</h2><p>代理原OnSubscribe,call阶段发射信息前搞了个for循环调用而已<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//源代码</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">fastPath</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> endIndex = <span class="keyword">this</span>.endOfRange + <span class="number">1L</span>;</span><br><span class="line">            <span class="keyword">final</span> Subscriber&lt;? <span class="keyword">super</span> Integer&gt; childSubscriber = <span class="keyword">this</span>.childSubscriber;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">long</span> index = currentIndex; index != endIndex; index++) &#123;</span><br><span class="line">                <span class="keyword">if</span> (childSubscriber.isUnsubscribed()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                childSubscriber.onNext((<span class="keyword">int</span>) index);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (!childSubscriber.isUnsubscribed()) &#123;</span><br><span class="line">                childSubscriber.onCompleted();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//简化代码</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> Observable&lt;Integer&gt; <span class="title">range</span><span class="params">(<span class="keyword">int</span> start, <span class="keyword">int</span> end)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> create(<span class="keyword">new</span> OnSubscribe&lt;Integer&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">call</span><span class="params">( Subscriber subscriber)</span> </span>&#123;</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = start; i &lt; end; i++) &#123;</span><br><span class="line">                    subscriber.onNext(i);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h2 id="windown"><a href="#windown" class="headerlink" title="windown()"></a>windown()</h2><p>类似于buffer，不过buffer生成的是一个List集合，windown生成的是一个Observable,可以进行再次订阅</p><h2 id="flatMap-done"><a href="#flatMap-done" class="headerlink" title="flatMap() done-"></a>flatMap() done-</h2><p>类似于java8的flatMap,将多个Stream汇聚成一个</p><h2 id="startwith-concat"><a href="#startwith-concat" class="headerlink" title="startwith() concat()"></a>startwith() concat()</h2><h2 id="from-done"><a href="#from-done" class="headerlink" title="from() done"></a>from() done</h2><h2 id="reduce-done"><a href="#reduce-done" class="headerlink" title="reduce() done"></a>reduce() done</h2><h2 id="retry-important"><a href="#retry-important" class="headerlink" title="retry() important"></a>retry() important</h2><p>首先，来了解一下.repeat()和.retry()之间最直观的区别是什么？这个问题并不难：区别就在于什么样的终止事件会触发重订阅。</p><ul><li><p>当.repeat()接收到.onCompleted()事件后触发重订阅。</p></li><li><p>当.retry()接收到.onError()事件后触发重订阅。</p></li></ul><p>然而，这种简单的叙述尚不能令人满意。试想如果你要实现一个延迟数秒的重订阅该如何去做？或者想通过观察错误来决定是否应该重订阅呢？这种情况下就需要.repeatWhen()和.retryWhen()的介入了，因为它们允许你为重试提供自定义逻辑</p><h2 id="share-important"><a href="#share-important" class="headerlink" title="share() important"></a>share() important</h2><h2 id="delay-done"><a href="#delay-done" class="headerlink" title="delay() done"></a>delay() done</h2><h2 id="refCount-计数器"><a href="#refCount-计数器" class="headerlink" title="refCount() 计数器"></a>refCount() 计数器</h2><h1 id="参考及推荐的文章"><a href="#参考及推荐的文章" class="headerlink" title="参考及推荐的文章"></a>参考及推荐的文章</h1><p><a href="https://blog.csdn.net/TellH/article/details/71534704" target="_blank" rel="noopener">https://blog.csdn.net/TellH/article/details/71534704</a></p><h4 id="自定义操作符注意点"><a href="#自定义操作符注意点" class="headerlink" title="自定义操作符注意点"></a>自定义操作符注意点</h4><p><a href="http://mushuichuan.com/2016/02/05/rxjava-operator-10/" target="_blank" rel="noopener">http://mushuichuan.com/2016/02/05/rxjava-operator-10/</a></p><h4 id="retry和repeat的思考译文"><a href="#retry和repeat的思考译文" class="headerlink" title="retry和repeat的思考译文"></a>retry和repeat的思考译文</h4><p><a href="https://www.jianshu.com/p/023a5f60e6d0" target="_blank" rel="noopener">https://www.jianshu.com/p/023a5f60e6d0</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;为什么学习rxjava&quot;&gt;&lt;a href=&quot;#为什么学习rxjava&quot; class=&quot;headerlink&quot; title=&quot;为什么学习rxjava&quot;&gt;&lt;/a&gt;为什么学习rxjava&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;1.它是什么&lt;/li&gt;
&lt;li&gt;2.解决了什么问题&lt;/l
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vertx-circuitBreadker源码解析</title>
    <link href="http://yoursite.com/2018/09/09/vertx-circuitBreadker%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/09/09/vertx-circuitBreadker源码解析/</id>
    <published>2018-09-09T07:50:18.000Z</published>
    <updated>2018-09-09T07:50:18.602Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>vertx httpserver源码解析</title>
    <link href="http://yoursite.com/2018/08/27/vertx-httpserver%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/27/vertx-httpserver源码解析/</id>
    <published>2018-08-27T02:01:38.000Z</published>
    <updated>2018-09-04T12:37:35.366Z</updated>
    
    <content type="html"><![CDATA[<p>大致梳理vertx发布httpserver的流程</p><a id="more"></a><h1 id="HttpServer-demo示例"><a href="#HttpServer-demo示例" class="headerlink" title="HttpServer demo示例"></a>HttpServer demo示例</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zoufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServerVerticle</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//请求到达时通知</span></span><br><span class="line">        vertx.createHttpServer().requestHandler(req -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (req.uri().equals(<span class="string">"/hello"</span>) &amp;&amp; req.method().equals(HttpMethod.GET)) &#123;</span><br><span class="line">                req.response()</span><br><span class="line">                        .putHeader(<span class="string">"content-type"</span>, <span class="string">"text/plain"</span>)</span><br><span class="line">                        .end(<span class="string">"Hello World!"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                req.response().setStatusCode(<span class="number">404</span>).end();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).listen(<span class="number">8080</span>, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName() + <span class="string">" : listen 8080 success !!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vertx vertx = Vertx.vertx();</span><br><span class="line">        vertx.deployVerticle(HelloWorldServerVerticle.class.getName(), <span class="keyword">new</span> DeploymentOptions().setInstances(<span class="number">8</span>));</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>正常我们的httpServer是这样启动的，光看这个不看源码也能大概知道这个httpServer本质是netty的EventLoopGroup在监听8080端口，这样就有几个问题了：</p><ul><li>1.vertx的eventLoop和netty的EventLoop到底是一个什么关系？</li><li>2.netty的Boos EventLoop和work EventLoop在vertx中是怎么交互的？</li></ul><p>下面以实例demo为例进入源码分析<br>跟进HttpServerImpl的listen（）,里面代码很长，主要还是netty Bootstrap的应用。简单描述下主要分为三部分</p><ul><li>1.设置HttpServer的协议，是HTTPS还是HTTP</li><li><p>2.设置netty的Bootstrap,后续分析他的boss EventLoopGroup和work EventLoopGroup</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">      bootstrap.group(vertx.getAcceptorEventLoopGroup(), availableWorkers);</span><br><span class="line">      applyConnectionOptions(bootstrap);</span><br></pre></td></tr></table></figure></li><li><p>3.执行bootStrap的端口绑定，并添加监听回调</p></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">bindFuture = AsyncResolveConnectHelper.doBind(vertx, SocketAddress.inetSocketAddress(port, host), bootstrap);</span><br><span class="line">         bindFuture.addListener(res -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (res.failed()) &#123;</span><br><span class="line">             vertx.sharedHttpServers().remove(id);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             Channel serverChannel = res.result();</span><br><span class="line">             HttpServerImpl.<span class="keyword">this</span>.actualPort = ((InetSocketAddress)serverChannel.localAddress()).getPort();</span><br><span class="line">             serverChannelGroup.add(serverChannel);</span><br><span class="line">             VertxMetrics metrics = vertx.metricsSPI();</span><br><span class="line">             <span class="keyword">this</span>.metrics = metrics != <span class="keyword">null</span> ? metrics.createMetrics(<span class="keyword">this</span>, <span class="keyword">new</span> SocketAddressImpl(port, host), options) : <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br></pre></td></tr></table></figure><h1 id="HttpServer的Boss-EventLoopGroup"><a href="#HttpServer的Boss-EventLoopGroup" class="headerlink" title="HttpServer的Boss EventLoopGroup"></a>HttpServer的Boss EventLoopGroup</h1><p>这个很简单，从源码可以看到httpServer的 Boss eventLoopGrou就是vertx初始化生成的单线程eventLoopGroup<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//vertxImpl的构造方法源码，默认100%是I/O事件，监听Selector的socket的连接事件，专门提供给netty的boss EvenLoopGroup</span></span><br><span class="line">acceptorEventLoopGroup = transport.eventLoopGroup(<span class="number">1</span>, acceptorEventLoopThreadFactory, <span class="number">100</span>);</span><br></pre></td></tr></table></figure></p><p>不过现在我们有了两个问题：</p><ul><li>1.上面的demo里我们设置了8个verticle，按照我们代码的start()方法，这些verticle发布的时候是不是也会创建8个HttpServer？</li><li>2.netty work EventLoop是怎么和vertx的EventLoop关联的？</li></ul><h1 id="httpserver的Work-EventLoopGroup"><a href="#httpserver的Work-EventLoopGroup" class="headerlink" title="httpserver的Work EventLoopGroup"></a>httpserver的Work EventLoopGroup</h1><p>接上面的workEventLoop,HttpServerImpl是写的availableWorkers参数</p><p>参看HtttpServerImpl对这个字段的定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> VertxEventLoopGroup availableWorkers = <span class="keyword">new</span> VertxEventLoopGroup();</span><br></pre></td></tr></table></figure><p>进入这个VertxEventLoopGroup可以看到构造后里面其实没有EvenLoop的，是一个空list</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"> <span class="keyword">private</span> <span class="keyword">int</span> pos;</span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> List&lt;EventLoopHolder&gt; workers = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"></span><br><span class="line"> <span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> EventLoop <span class="title">next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (workers.isEmpty()) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException();</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     EventLoop worker = workers.get(pos).worker;</span><br><span class="line">     pos++;</span><br><span class="line">     checkPos();</span><br><span class="line">     <span class="keyword">return</span> worker;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addWorker</span><span class="params">(EventLoop worker)</span> </span>&#123;</span><br><span class="line">   EventLoopHolder holder = findHolder(worker);</span><br><span class="line">   <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">     workers.add(<span class="keyword">new</span> EventLoopHolder(worker));</span><br><span class="line">   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">     holder.count++;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>空集合就有问题，那EventLoop是啥时候添加进去这个availableWorkers的呢，我们回到HttpServerImpl,看这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">addHandler</span><span class="params">(T handler, ContextImpl context)</span> </span>&#123;</span><br><span class="line">    EventLoop worker = context.nettyEventLoop();</span><br><span class="line">    availableWorkers.addWorker(worker);</span><br><span class="line">    Handlers&lt;T&gt; handlers = <span class="keyword">new</span> Handlers&lt;&gt;();</span><br><span class="line">    Handlers&lt;T&gt; prev = handlerMap.putIfAbsent(worker, handlers);</span><br><span class="line">    <span class="keyword">if</span> (prev != <span class="keyword">null</span>) &#123;</span><br><span class="line">      handlers = prev;</span><br><span class="line">    &#125;</span><br><span class="line">    handlers.addHandler(<span class="keyword">new</span> HandlerHolder&lt;&gt;(context, handler));</span><br><span class="line">    hasHandlers = <span class="keyword">true</span>;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>具体是在listen方法里调用了这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">listenContext = vertx.getOrCreateContext();</span><br><span class="line"></span><br><span class="line">addHandlers(<span class="keyword">this</span>, listenContext);</span><br></pre></td></tr></table></figure><p>这样就清楚了HttpServerImpl是用了当前线程的Context 的eventlLoop加入list,我们这里是生成了8个context,我们可以debug看到结果，添加了8个EventLoop的到了一个availableWorkers.</p><p>那么这8个是怎么加入到一个availableWorkers的呢？我们看到是有生成8个HttpServerImpl的，但bootstrap实际是生成8个么？其实不是的，只生成了一个，我们再次看代码。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> HttpServer <span class="title">listen</span><span class="params">(<span class="keyword">int</span> port, String host, Handler&lt;AsyncResult&lt;HttpServer&gt;&gt; listenHandler)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (requestStream.handler() == <span class="keyword">null</span> &amp;&amp; wsStream.handler() == <span class="keyword">null</span>) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Set request or websocket handler first"</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (listening) &#123;</span><br><span class="line">     <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"Already listening"</span>);</span><br><span class="line">   &#125;</span><br><span class="line"><span class="comment">//获取当前verticle执行线程的Context</span></span><br><span class="line">   listenContext = vertx.getOrCreateContext();</span><br><span class="line">   listening = <span class="keyword">true</span>;</span><br><span class="line"><span class="comment">//是否HTTPS</span></span><br><span class="line">   serverOrigin = (options.isSsl() ? <span class="string">"https"</span> : <span class="string">"http"</span>) + <span class="string">"://"</span> + host + <span class="string">":"</span> + port;</span><br><span class="line">   List&lt;HttpVersion&gt; applicationProtocols = options.getAlpnVersions();</span><br><span class="line">   <span class="keyword">if</span> (listenContext.isWorkerContext()) &#123;</span><br><span class="line">     applicationProtocols =  applicationProtocols.stream().filter(v -&gt; v != HttpVersion.HTTP_2).collect(Collectors.toList());</span><br><span class="line">   &#125;</span><br><span class="line">   sslHelper.setApplicationProtocols(applicationProtocols);</span><br><span class="line">   <span class="keyword">synchronized</span> (vertx.sharedHttpServers()) &#123;</span><br><span class="line">     <span class="keyword">this</span>.actualPort = port; <span class="comment">// Will be updated on bind for a wildcard port</span></span><br><span class="line">     id = <span class="keyword">new</span> ServerID(port, host);</span><br><span class="line"> <span class="comment">//这里就是只生成一个bootstrap的关键代码，ServerID重写了hashcode方法，这些只要是监听同样的host</span></span><br><span class="line">   <span class="comment">//+port,取到的httpServerImpl就是同一个，这样bootstrap其实只生成了一个</span></span><br><span class="line">     HttpServerImpl shared = vertx.sharedHttpServers().get(id);</span><br><span class="line">     <span class="keyword">if</span> (shared == <span class="keyword">null</span> || port == <span class="number">0</span>) &#123;</span><br><span class="line">       serverChannelGroup = <span class="keyword">new</span> DefaultChannelGroup(<span class="string">"vertx-acceptor-channels"</span>, GlobalEventExecutor.INSTANCE);</span><br><span class="line"><span class="comment">//netty的EventLoopGroup</span></span><br><span class="line">       ServerBootstrap bootstrap = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">       bootstrap.group(vertx.getAcceptorEventLoopGroup(), availableWorkers);</span><br><span class="line">       applyConnectionOptions(bootstrap);</span><br><span class="line">       sslHelper.validate(vertx);</span><br><span class="line">       bootstrap.childHandler(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">             <span class="keyword">if</span> (requestStream.isPaused() || wsStream.isPaused()) &#123;</span><br><span class="line">               ch.close();</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line"><span class="comment">//https连接work channel处理</span></span><br><span class="line">             <span class="keyword">if</span> (sslHelper.isSSL()) &#123;</span><br><span class="line">               io.netty.util.concurrent.Future&lt;Channel&gt; handshakeFuture;</span><br><span class="line">               <span class="keyword">if</span> (options.isSni()) &#123;</span><br><span class="line">                 VertxSniHandler sniHandler = <span class="keyword">new</span> VertxSniHandler(sslHelper, vertx);</span><br><span class="line">                 pipeline.addLast(sniHandler);</span><br><span class="line">                 handshakeFuture = sniHandler.handshakeFuture();</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 SslHandler handler = <span class="keyword">new</span> SslHandler(sslHelper.createEngine(vertx));</span><br><span class="line">                 pipeline.addLast(<span class="string">"ssl"</span>, handler);</span><br><span class="line">                 handshakeFuture = handler.handshakeFuture();</span><br><span class="line">               &#125;</span><br><span class="line">               handshakeFuture.addListener(future -&gt; &#123;</span><br><span class="line">                 <span class="keyword">if</span> (future.isSuccess()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (options.isUseAlpn()) &#123;</span><br><span class="line">                     SslHandler sslHandler = pipeline.get(SslHandler.class);</span><br><span class="line">                     String protocol = sslHandler.applicationProtocol();</span><br><span class="line">                     <span class="keyword">if</span> (<span class="string">"h2"</span>.equals(protocol)) &#123;</span><br><span class="line">                       handleHttp2(ch);</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       handleHttp1(ch);</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                     handleHttp1(ch);</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   HandlerHolder&lt;HttpHandlers&gt; handler = httpHandlerMgr.chooseHandler(ch.eventLoop());</span><br><span class="line">                   handler.context.executeFromIO(() -&gt; handler.handler.exceptionHandler.handle(future.cause()));</span><br><span class="line">                 &#125;</span><br><span class="line">               &#125;);</span><br><span class="line">             &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">               <span class="keyword">if</span> (DISABLE_H2C) &#123;</span><br><span class="line">                 handleHttp1(ch);</span><br><span class="line">               &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                 IdleStateHandler idle;</span><br><span class="line">                 <span class="keyword">if</span> (options.getIdleTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">                   pipeline.addLast(<span class="string">"idle"</span>, idle = <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, options.getIdleTimeout()));</span><br><span class="line">                 &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                   idle = <span class="keyword">null</span>;</span><br><span class="line">                 &#125;</span><br><span class="line">                 <span class="comment">// Handler that detects whether the HTTP/2 connection preface or just process the request</span></span><br><span class="line">                 <span class="comment">// with the HTTP 1.x pipeline to support H2C with prior knowledge, i.e a client that connects</span></span><br><span class="line">                 <span class="comment">// and uses HTTP/2 in clear text directly without an HTTP upgrade.</span></span><br><span class="line">                 pipeline.addLast(<span class="keyword">new</span> Http1xOrH2CHandler() &#123;</span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">configure</span><span class="params">(ChannelHandlerContext ctx, <span class="keyword">boolean</span> h2c)</span> </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span> (idle != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       <span class="comment">// It will be re-added but this way we don't need to pay attention to order</span></span><br><span class="line">                       pipeline.remove(idle);</span><br><span class="line">                     &#125;</span><br><span class="line">                     <span class="keyword">if</span> (h2c) &#123;</span><br><span class="line">                       handleHttp2(ctx.channel());</span><br><span class="line">                     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="comment">//我们默认http请求处理</span></span><br><span class="line">                       handleHttp1(ch);</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">userEventTriggered</span><span class="params">(ChannelHandlerContext ctx, Object evt)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     <span class="keyword">if</span> (evt <span class="keyword">instanceof</span> IdleStateEvent &amp;&amp; ((IdleStateEvent) evt).state() == IdleState.ALL_IDLE) &#123;</span><br><span class="line">                       ctx.close();</span><br><span class="line">                     &#125;</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="meta">@Override</span></span><br><span class="line">                   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exceptionCaught</span><span class="params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                     <span class="keyword">super</span>.exceptionCaught(ctx, cause);</span><br><span class="line">                     HandlerHolder&lt;HttpHandlers&gt; handler = httpHandlerMgr.chooseHandler(ctx.channel().eventLoop());</span><br><span class="line">                     handler.context.executeFromIO(() -&gt; handler.handler.exceptionHandler.handle(cause));</span><br><span class="line">                   &#125;</span><br><span class="line">                 &#125;);</span><br><span class="line">               &#125;</span><br><span class="line">             &#125;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//添加listen端口的后处理器，同时将context的eventLoop加入HttpServer的avilableWorks中，初始化work EverntLoopGroup过程</span></span><br><span class="line">       addHandlers(<span class="keyword">this</span>, listenContext);</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="comment">//绑定端口</span></span><br><span class="line">         bindFuture = AsyncResolveConnectHelper.doBind(vertx, SocketAddress.inetSocketAddress(port, host), bootstrap);</span><br><span class="line">         bindFuture.addListener(res -&gt; &#123;</span><br><span class="line">           <span class="keyword">if</span> (res.failed()) &#123;</span><br><span class="line">             vertx.sharedHttpServers().remove(id);</span><br><span class="line">           &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">             Channel serverChannel = res.result();</span><br><span class="line">             HttpServerImpl.<span class="keyword">this</span>.actualPort = ((InetSocketAddress)serverChannel.localAddress()).getPort();</span><br><span class="line">             serverChannelGroup.add(serverChannel);</span><br><span class="line">             VertxMetrics metrics = vertx.metricsSPI();</span><br><span class="line">             <span class="keyword">this</span>.metrics = metrics != <span class="keyword">null</span> ? metrics.createMetrics(<span class="keyword">this</span>, <span class="keyword">new</span> SocketAddressImpl(port, host), options) : <span class="keyword">null</span>;</span><br><span class="line">           &#125;</span><br><span class="line">         &#125;);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (<span class="keyword">final</span> Throwable t) &#123;</span><br><span class="line">         <span class="comment">// Make sure we send the exception back through the handler (if any)</span></span><br><span class="line">         <span class="keyword">if</span> (listenHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">           vertx.runOnContext(v -&gt; listenHandler.handle(Future.failedFuture(t)));</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="comment">// No handler - log so user can see failure</span></span><br><span class="line">           log.error(t);</span><br><span class="line">         &#125;</span><br><span class="line">         listening = <span class="keyword">false</span>;</span><br><span class="line">         <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">       &#125;</span><br><span class="line"><span class="comment">//将httpServer放入map,ServerID为KEY</span></span><br><span class="line">       vertx.sharedHttpServers().put(id, <span class="keyword">this</span>);</span><br><span class="line">       actualServer = <span class="keyword">this</span>;</span><br><span class="line">     &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">       <span class="comment">// Server already exists with that host/port - we will use that</span></span><br><span class="line">       actualServer = shared;</span><br><span class="line">       <span class="keyword">this</span>.actualPort = shared.actualPort;</span><br><span class="line">       addHandlers(actualServer, listenContext);</span><br><span class="line">       VertxMetrics metrics = vertx.metricsSPI();</span><br><span class="line">       <span class="keyword">this</span>.metrics = metrics != <span class="keyword">null</span> ? metrics.createMetrics(<span class="keyword">this</span>, <span class="keyword">new</span> SocketAddressImpl(port, host), options) : <span class="keyword">null</span>;</span><br><span class="line">     &#125;</span><br><span class="line">     actualServer.bindFuture.addListener(future -&gt; &#123;</span><br><span class="line">       <span class="keyword">if</span> (listenHandler != <span class="keyword">null</span>) &#123;</span><br><span class="line">         <span class="keyword">final</span> AsyncResult&lt;HttpServer&gt; res;</span><br><span class="line">         <span class="keyword">if</span> (future.succeeded()) &#123;</span><br><span class="line">           res = Future.succeededFuture(HttpServerImpl.<span class="keyword">this</span>);</span><br><span class="line">         &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           res = Future.failedFuture(future.cause());</span><br><span class="line">           listening = <span class="keyword">false</span>;</span><br><span class="line">         &#125;</span><br><span class="line">         listenContext.runOnContext((v) -&gt; listenHandler.handle(res));</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (future.failed()) &#123;</span><br><span class="line">         listening  = <span class="keyword">false</span>;</span><br><span class="line">         <span class="comment">// No handler - log so user can see failure</span></span><br><span class="line">         log.error(future.cause());</span><br><span class="line">       &#125;</span><br><span class="line">     &#125;);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><h2 id="总结："><a href="#总结：" class="headerlink" title="总结："></a>总结：</h2><ul><li>1.如果verticle中创建了多个httpServer，监听同一个ip端口，只创建一个Bootstrap。</li><li>2.bootstrap关联的Boss EventLoopGroup是vertx的accpetEventLoopGroup，默认一个线程</li><li>3.httpServer 的work EventLoopGroup其实是verticle Context绑定的EventLoop集合。</li></ul><p>这样每一个http请求过来，获取连接的是accpetEventLoop,处理后续的读写数据是vertx的EventLoopGroup。over</p><h1 id="其他细节"><a href="#其他细节" class="headerlink" title="其他细节"></a>其他细节</h1><h2 id="http1-1的处理"><a href="#http1-1的处理" class="headerlink" title="http1.1的处理"></a>http1.1的处理</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//httpServerImpl</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">handleHttp1</span><span class="params">(Channel ch)</span> </span>&#123;</span><br><span class="line">    HandlerHolder&lt;HttpHandlers&gt; holder = httpHandlerMgr.chooseHandler(ch.eventLoop());</span><br><span class="line">    <span class="keyword">if</span> (holder == <span class="keyword">null</span>) &#123;</span><br><span class="line">      sendServiceUnavailable(ch);</span><br><span class="line">      <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    configureHttp1(ch.pipeline(), holder);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">configureHttp1</span><span class="params">(ChannelPipeline pipeline, HandlerHolder&lt;HttpHandlers&gt; holder)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (logEnabled) &#123;</span><br><span class="line">      pipeline.addLast(<span class="string">"logging"</span>, <span class="keyword">new</span> LoggingHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (USE_FLASH_POLICY_HANDLER) &#123;</span><br><span class="line">      pipeline.addLast(<span class="string">"flashpolicy"</span>, <span class="keyword">new</span> FlashPolicyHandler());</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//添加http解码器</span></span><br><span class="line">    pipeline.addLast(<span class="string">"httpDecoder"</span>, <span class="keyword">new</span> HttpRequestDecoder(options.getMaxInitialLineLength()</span><br><span class="line">        , options.getMaxHeaderSize(), options.getMaxChunkSize(), <span class="keyword">false</span>, options.getDecoderInitialBufferSize()));</span><br><span class="line"><span class="comment">//添加http编码器</span></span><br><span class="line">    pipeline.addLast(<span class="string">"httpEncoder"</span>, <span class="keyword">new</span> VertxHttpResponseEncoder());</span><br><span class="line">    <span class="keyword">if</span> (options.isDecompressionSupported()) &#123;</span><br><span class="line">      pipeline.addLast(<span class="string">"inflater"</span>, <span class="keyword">new</span> HttpContentDecompressor(<span class="keyword">true</span>));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//合并数据</span></span><br><span class="line">    <span class="keyword">if</span> (options.isCompressionSupported()) &#123;</span><br><span class="line">      pipeline.addLast(<span class="string">"deflater"</span>, <span class="keyword">new</span> HttpChunkContentCompressor(options.getCompressionLevel()));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//ssl支持</span></span><br><span class="line">    <span class="keyword">if</span> (sslHelper.isSSL() || options.isCompressionSupported()) &#123;</span><br><span class="line">      <span class="comment">// only add ChunkedWriteHandler when SSL is enabled otherwise it is not needed as FileRegion is used.</span></span><br><span class="line">      pipeline.addLast(<span class="string">"chunkedWriter"</span>, <span class="keyword">new</span> ChunkedWriteHandler());       <span class="comment">// For large file / sendfile support</span></span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//空闲连接处理</span></span><br><span class="line">    <span class="keyword">if</span> (options.getIdleTimeout() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">      pipeline.addLast(<span class="string">"idle"</span>, <span class="keyword">new</span> IdleStateHandler(<span class="number">0</span>, <span class="number">0</span>, options.getIdleTimeout()));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!DISABLE_H2C) &#123;</span><br><span class="line">      pipeline.addLast(<span class="string">"h2c"</span>, <span class="keyword">new</span> Http2UpgradeHandler());</span><br><span class="line">    &#125;</span><br><span class="line">    Http1xServerHandler handler;</span><br><span class="line"><span class="comment">//是否webSocket连接处理</span></span><br><span class="line">    <span class="keyword">if</span> (DISABLE_WEBSOCKETS) &#123;</span><br><span class="line">      <span class="comment">// As a performance optimisation you can set a system property to disable websockets altogether which avoids</span></span><br><span class="line">      <span class="comment">// some casting and a header check</span></span><br><span class="line">      handler = <span class="keyword">new</span> Http1xServerHandler(sslHelper, options, serverOrigin, holder, metrics);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      handler = <span class="keyword">new</span> ServerHandlerWithWebSockets(sslHelper, options, serverOrigin, holder, metrics);</span><br><span class="line">    &#125;</span><br><span class="line">    handler.addHandler(conn -&gt; &#123;</span><br><span class="line">      connectionMap.put(pipeline.channel(), conn);</span><br><span class="line">    &#125;);</span><br><span class="line">    handler.removeHandler(conn -&gt; &#123;</span><br><span class="line">      connectionMap.remove(pipeline.channel());</span><br><span class="line">    &#125;);</span><br><span class="line"><span class="comment">//添加我们自定义的requestHadler,我们也就是在这上面折腾- -</span></span><br><span class="line">    pipeline.addLast(<span class="string">"handler"</span>, handler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h2 id="pause和resume"><a href="#pause和resume" class="headerlink" title="pause和resume"></a>pause和resume</h2><p>vertx对于request和response的操作其实本质上是netty对channel的操作，而pause和resume本质是改变channel的autoRead的配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ConnectionBase</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doPause</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chctx.channel().config().setAutoRead(<span class="keyword">false</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">doResume</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    chctx.channel().config().setAutoRead(<span class="keyword">true</span>);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>autoRead这个配置有什么用呢？</p><p>避免分析又臭又长，先说结论，主要有两个作用：</p><ul><li><ol><li>如果对serverChannel设置，是暂停对serverChannel的对channel的注册</li></ol></li><li><ol start="2"><li>如果是对workChannel设置，是暂停channel对流的读取</li></ol></li></ul><p>先整体看下DefaultChannelPipeline里面HeadContext的方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelActive</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelActive();<span class="comment">//本质还是调用channelActive方法- -</span></span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelReadComplete</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelReadComplete();<span class="comment">//本质还是调用channelReadComplete方法，╮(╯▽╰)╭</span></span><br><span class="line"></span><br><span class="line">            readIfIsAutoRead();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">readIfIsAutoRead</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.config().isAutoRead()) &#123;</span><br><span class="line">                channel.read();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p><strong>channelActive和channelReadComplete这两个事件是什么时候触发呢？</strong></p><p>channelActive是在Channel(netty的ServerChannel和子channel)注册到selector时触发<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">register0</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               <span class="comment">// check if the channel is still open as it could be closed in the mean time when the register</span></span><br><span class="line">               <span class="comment">// call was outside of the eventLoop</span></span><br><span class="line">               <span class="keyword">if</span> (!promise.setUncancellable() || !ensureOpen(promise)) &#123;</span><br><span class="line">                   <span class="keyword">return</span>;</span><br><span class="line">               &#125;</span><br><span class="line">               <span class="keyword">boolean</span> firstRegistration = neverRegistered;</span><br><span class="line">               doRegister();<span class="comment">//注册读事件</span></span><br><span class="line">               neverRegistered = <span class="keyword">false</span>;</span><br><span class="line">               registered = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">               <span class="comment">// Ensure we call handlerAdded(...) before we actually notify the promise. This is needed as the</span></span><br><span class="line">               <span class="comment">// user may already fire events through the pipeline in the ChannelFutureListener.</span></span><br><span class="line">               pipeline.invokeHandlerAddedIfNeeded();</span><br><span class="line"></span><br><span class="line">               safeSetSuccess(promise);</span><br><span class="line">               pipeline.fireChannelRegistered();</span><br><span class="line">               <span class="comment">// Only fire a channelActive if the channel has never been registered. This prevents firing</span></span><br><span class="line">               <span class="comment">// multiple channel actives if the channel is deregistered and re-registered.</span></span><br><span class="line">               <span class="keyword">if</span> (isActive()) &#123;</span><br><span class="line">                   <span class="keyword">if</span> (firstRegistration) &#123;</span><br><span class="line">                       pipeline.fireChannelActive();</span><br><span class="line">                   &#125; <span class="keyword">else</span> <span class="keyword">if</span> (config().isAutoRead()) &#123;</span><br><span class="line">                       <span class="comment">// This channel was registered before and autoRead() is set. This means we need to begin read</span></span><br><span class="line">                       <span class="comment">// again so that we process inbound data.</span></span><br><span class="line">                       <span class="comment">//</span></span><br><span class="line">                       <span class="comment">// See https://github.com/netty/netty/issues/4805</span></span><br><span class="line">                       beginRead();</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">               <span class="comment">// Close the channel directly to avoid FD leak.</span></span><br><span class="line">               closeForcibly();</span><br><span class="line">               closeFuture.setClosed();</span><br><span class="line">               safeSetFailure(promise, t);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>netty初始化完成时，bootstrap的serverChannelPipeline内部是这样的</p><p>head–&gt;ServerBootstrapAcceptor–&gt;tail</p><p>pipeline执行fireChannelActive()是从headContext开始触发，最后执行的是<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// AbstractNioChannel.java中的AbstractNioUnsafe类</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">doBeginRead</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">// Channel.read() or ChannelHandlerContext.read() was called</span></span><br><span class="line">        <span class="keyword">final</span> SelectionKey selectionKey = <span class="keyword">this</span>.selectionKey;</span><br><span class="line">        <span class="keyword">if</span> (!selectionKey.isValid()) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        readPending = <span class="keyword">true</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> <span class="keyword">int</span> interestOps = selectionKey.interestOps();</span><br><span class="line">        <span class="keyword">if</span> ((interestOps &amp; readInterestOp) == <span class="number">0</span>) &#123;</span><br><span class="line">            selectionKey.interestOps(interestOps | readInterestOp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这个autoread过程是为serverchannel注册accept和读事件</p><p>后续客户端开始于服务端连接，触发selector的accept/read事件,serverChannel的ServerBootstrapAcceptor创建了子chuannel，并向work EventLoop的selector上注册子channel，子channel循环前面的流程注册读事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Unknown channel option: "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to set a channel option: "</span> + child, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>接着客户端向服务端发送数据，触发子channel的read事件</p><p>而channelReadComplete是读事件后触发。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Also check for readOps of 0 to workaround possible JDK bug which may otherwise lead</span></span><br><span class="line">            <span class="comment">// to a spin loop</span></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();</span><br><span class="line">                <span class="keyword">if</span> (!ch.isOpen()) &#123;</span><br><span class="line">                    <span class="comment">// Connection already closed - no need to handle write.</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//AbstractNioMessageChannel .read()</span></span><br><span class="line"><span class="keyword">int</span> size = readBuf.size();</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; size; i ++) &#123;</span><br><span class="line">                    readPending = <span class="keyword">false</span>;</span><br><span class="line">                    pipeline.fireChannelRead(readBuf.get(i));</span><br><span class="line">                &#125;</span><br><span class="line">                readBuf.clear();</span><br><span class="line">                allocHandle.readComplete();<span class="comment">//重新计算缓冲区大小并通知pipeline触发fireChannelReadComplete();</span></span><br><span class="line">                pipeline.fireChannelReadComplete();</span><br></pre></td></tr></table></figure></p><p>再次总结下，autoRead这个属性在netty里面的作用是自动向selector注册读事件，如果关闭的话netty就不会从channel中读取数据。</p><p>按照网上有的文章的说法，这个autoread是利用了tcp的负反馈机制，调节消费端的消费窗口的大小达到控制发送端发送速率的作用。</p><h2 id="参考相关"><a href="#参考相关" class="headerlink" title="参考相关"></a>参考相关</h2><p>netty的autoRead</p><p><a href="https://www.jianshu.com/p/8f22675d71ac" target="_blank" rel="noopener">https://www.jianshu.com/p/8f22675d71ac</a></p>]]></content>
    
    <summary type="html">
    
      基于netty的轻量级框架
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
      <category term="vertx" scheme="http://yoursite.com/tags/vertx/"/>
    
  </entry>
  
  <entry>
    <title>vert.x源码解析</title>
    <link href="http://yoursite.com/2018/08/21/vert-x%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/08/21/vert-x源码解析/</id>
    <published>2018-08-21T11:14:22.000Z</published>
    <updated>2018-08-27T02:00:48.569Z</updated>
    
    <content type="html"><![CDATA[<h2 id="vertx是什么"><a href="#vertx是什么" class="headerlink" title="vertx是什么"></a>vertx是什么</h2><p>前面我们有分析过netty的源码，netty是一个异步非阻塞的NIO框架，主要是用于网络编程。而vertx是基于netty构建的应用平台,复用netty的EvenLoopGroup实现的reactor模型。是一个轻量级高性能的异步框架。</p><a id="more"></a><h2 id="一、vertx结构"><a href="#一、vertx结构" class="headerlink" title="一、vertx结构"></a>一、vertx结构</h2><p>这节内容主要来自官方文档</p><h3 id="1-1Verticle"><a href="#1-1Verticle" class="headerlink" title="1.1Verticle"></a>1.1Verticle</h3><p>如果说vertx是一个操作系统，verticle就是运行在上面的软件，verticle是需要部署在vertx实例上运行的。<br>一个vertx实例可以有多个verticle，不同的verticle通过EventBus传递消息verticle有父子verticles概念</p><p>Verticle三种类型</p><h4 id="标准Verticle"><a href="#标准Verticle" class="headerlink" title="标准Verticle"></a>标准Verticle</h4><p>标准verticles当创建和调用start方法时分配一个event loop。调用执行都在相同的event loop上。</p><p>这意味着我们可以保证您的verticles实例中的所有代码总是都执行相同的事件循环上 (只要你不调用它自己创建的线程!)。</p><p>这意味着可以在程序里作为单线程编写所有的代码，把担心线程和扩展的问题交给Vert.x。没有更多令人担忧的同步和更多不稳定的问题，也避免了多线程死锁的问题</p><h4 id="单线程-Work-Verticle"><a href="#单线程-Work-Verticle" class="headerlink" title="单线程 Work Verticle"></a>单线程 Work Verticle</h4><p>Worker verticles就像标准的verticles一样，但不使用事件循环执行，从 Vert.x worker线程池使用一个线程。</p><p>worker verticles 专为调用阻塞的代码，因为他们不会阻止任何事件循环。<br>如果你不想使用worker verticles运行阻塞的代码，可以在事件循环上直接运行内联阻塞代<br>码。</p><p>如果您要以worker verticles的方式部署verticle，需要调用 setWorker.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">DeploymentOptions options = <span class="keyword">new</span> DeploymentOptions().setWorker(<span class="keyword">true</span>);</span><br><span class="line">vertx.deployVerticle(<span class="string">"com.mycompany.MyOrderProcessorVerticle"</span>, options);</span><br></pre></td></tr></table></figure><p>Worker verticle实例永远不会有多个线程并发执行 ，但可以在不同的时间由不同的线程执行。</p><h4 id="1-1-3-多线程的Work-Verticle"><a href="#1-1-3-多线程的Work-Verticle" class="headerlink" title="1.1.3 多线程的Work Verticle"></a>1.1.3 多线程的Work Verticle</h4><p>多线程的worker verticle就像正常worker verticle，但它是可以由不同的线程同时执行。</p><p><strong>警告</strong></p><blockquote><p>多线程的worker verticle 是一项高级的功能，大多数应用程序会对他们来说没有必要。因为在这些 verticles 并发，你必须非常小心，使用标准的 Java 技术的多线程编程，以保持verticle一致状态。</p></blockquote><h4 id="verticles的部署"><a href="#verticles的部署" class="headerlink" title="verticles的部署"></a>verticles的部署</h4><ul><li>verticle实例化<br>verticles名称用于查找特定的VerticleFactory ，将用来实例化实际verticles实例。</li></ul><p>不同verticle工厂可用于实例化不同语言verticles和其他各种原因，例如装载服务和从Maven在运行时得到verticles。<br>这允许您从 Vert.x 支持的任何语言编写的其他语言verticles部署 </p><ul><li>指定verticle实例数</li></ul><p>在部署时verticle使用verticle的名称，可以指定您要部署的verticle实例的数目:</p><blockquote><p>DeploymentOptions options = new DeploymentOptions().setInstances(16);<br>vertx.deployVerticle(“com.mycompany.MyOrderProcessorVerticle”, options);<br>用于跨多个内核轻松扩展。例如，您可能有 web 服务器verticle部署，服务器是多核的，你想要部署多个实例来充分利用所有核心。</p></blockquote><h4 id="怎么样找到Verticle-Factories"><a href="#怎么样找到Verticle-Factories" class="headerlink" title="怎么样找到Verticle Factories"></a>怎么样找到Verticle Factories</h4><ul><li>ServiceLoader 在 Vert.x 启动时从类路径中加载并注册。(spi方式)</li><li>通过编程方式注册和注销Verticle factories，使用registerVerticleFactory和unregisterVerticleFactory。（编码注册）</li></ul><h3 id="ShareDate"><a href="#ShareDate" class="headerlink" title="ShareDate"></a>ShareDate</h3><p>Shared data contains functionality that allows you to safely share data between different parts of your application, or different applications in the same Vert.x instance or across a cluster of Vert.x instances.</p><p>Shared data provides:</p><ul><li>synchronous shared maps (local)</li></ul><p>本质就是一个ConcurrntHashMap&lt;String,LocalMap&lt;K,V&gt;&gt;<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">LocalMap&lt;String, String&gt; map1 = sd.getLocalMap(<span class="string">"mymap1"</span>);</span><br><span class="line"></span><br><span class="line">map1.put(<span class="string">"foo"</span>, <span class="string">"bar"</span>); <span class="comment">// Strings are immutable so no need to copy</span></span><br><span class="line"></span><br><span class="line">LocalMap&lt;String, Buffer&gt; map2 = sd.getLocalMap(<span class="string">"mymap2"</span>);</span><br><span class="line"></span><br><span class="line">map2.put(<span class="string">"eek"</span>, Buffer.buffer().appendInt(<span class="number">123</span>)); <span class="comment">// This buffer will be copied before adding to map</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Then... in another part of your application:</span></span><br><span class="line"></span><br><span class="line">map1 = sd.getLocalMap(<span class="string">"mymap1"</span>);</span><br><span class="line"></span><br><span class="line">String val = map1.get(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line">map2 = sd.getLocalMap(<span class="string">"mymap2"</span>);</span><br><span class="line"></span><br><span class="line">Buffer buff = map2.get(<span class="string">"eek"</span>);</span><br></pre></td></tr></table></figure></p><ul><li><p>asynchronous maps (local or cluster-wide)</p></li><li><p>asynchronous locks (local or cluster-wide)</p></li><li><p>asynchronous counters (local or cluster-wide)</p><h3 id="Context"><a href="#Context" class="headerlink" title="Context"></a>Context</h3><p>当Vert.x提供一个事件的处理程序或调用Verticle的开始或停止的方法，执行与Context相关联。类似于netty的ChannelContext，不过Vertx的Context是与线程绑定，netty的ChannelContext是和Channel绑定，有一丢丢的区别。</p></li></ul><p>因为一般Context是event-loop context 绑定特定的事件循环线程。因此，对于这方面的执行总是发生在该完全相同的事件循环线程。</p><p>若要获得context，请使用getOrCreateContext方法:<br>Context context = vertx.getOrCreateContext();<br>如果当前线程具有一个与它相关联的context，它重复使用context对象。如果不创建新实例的context。您可以测试您取得的context的类型:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Context context = vertx.getOrCreateContext();</span><br><span class="line"><span class="keyword">if</span> (context.isEventLoopContext()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Context attached to Event Loop"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isWorkerContext()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Context attached to Worker Thread"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (context.isMultiThreadedWorkerContext()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Context attached to Worker Thread - multi threaded worker"</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (! Context.isOnVertxThread()) &#123;</span><br><span class="line">System.out.println(<span class="string">"Context not attached to a thread managed by vert.x"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>当您取得context对象时，您可以以异步方式在此context中运行代码。换句话说，您提交相同的context，异步执行任务:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">vertx.getOrCreateContext().runOnContext( (v) -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"This will be executed asynchronously in the same context"</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">//源码是这样提示的 Run the task asynchronously on this same context</span></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runOnContext</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executeAsync(task);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</span><br><span class="line">      <span class="comment">// Pool is already shut down</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>当几个处理程序在相同的context中运行时，他们可能想要分享数据。context对象提供方法来存储和获取在context中共享的数据。例如，它可以让你通过一些行动runOnContext运行数据：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">final</span> Context context = vertx.getOrCreateContext();</span><br><span class="line">context.put(<span class="string">"data"</span>, <span class="string">"hello"</span>);</span><br><span class="line">context.runOnContext((v) -&gt; &#123;</span><br><span class="line">String hello = context.get(<span class="string">"data"</span>);</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>context对象还可让您使用的config方法访问verticle配置。</p><h3 id="Handler"><a href="#Handler" class="headerlink" title="Handler"></a>Handler</h3><p>事件的回调处理，这个回调是如何执行呢？这个问题在下面标准Verticle部署这节源码分析会解答</p><p>### </p><h2 id="二、vertx示例demo"><a href="#二、vertx示例demo" class="headerlink" title="二、vertx示例demo"></a>二、vertx示例demo</h2><p>简单写个vertxdemo,这个也是是我们分析源码的入口<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@author</span> zoufeng</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@date</span> 2018/8/18</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloWorldServerVerticle3</span> <span class="keyword">extends</span> <span class="title">AbstractVerticle</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        request();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        Vertx vertx = Vertx.vertx();</span><br><span class="line">        vertx.deployVerticle(HelloWorldServerVerticle3.class.getName());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">request</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        vertx.createHttpServer(<span class="keyword">new</span> HttpServerOptions()).requestHandler(httpServerRequest -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (httpServerRequest.uri().equals(<span class="string">"/hello"</span>) &amp;&amp; httpServerRequest.method().equals(HttpMethod.GET)) &#123;</span><br><span class="line">                HttpServerResponse httpServerResponse = httpServerRequest.response().setChunked(<span class="keyword">true</span>);</span><br><span class="line">                vertx.createHttpClient(<span class="keyword">new</span> HttpClientOptions()</span><br><span class="line">                        .setKeepAlive(<span class="keyword">false</span>))</span><br><span class="line">                        .request(httpServerRequest.method(), <span class="number">80</span>, <span class="string">"www.qq.com"</span>, <span class="string">"/"</span>)</span><br><span class="line">                        .handler(response -&gt; &#123;</span><br><span class="line">                            System.out.println(<span class="string">"Received response with status code "</span> + response.statusCode());</span><br><span class="line"></span><br><span class="line">                            <span class="comment">//copy header</span></span><br><span class="line">                            response.headers().forEach(entry -&gt; &#123;</span><br><span class="line">                                httpServerResponse.putHeader(entry.getKey(), entry.getValue());</span><br><span class="line">                            &#125;);</span><br><span class="line">                            <span class="comment">//copy body writeStrea</span></span><br><span class="line">                            Pump.pump(response, httpServerResponse).start();</span><br><span class="line">                        &#125;).end();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                httpServerRequest.response().setStatusCode(<span class="number">404</span>).end(<span class="string">"not found"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;).listen(<span class="number">8089</span>, result -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (result.succeeded()) &#123;</span><br><span class="line">                System.out.println(<span class="string">"listen 8089 success !!"</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h2 id="三、vertx实例化的过程"><a href="#三、vertx实例化的过程" class="headerlink" title="三、vertx实例化的过程"></a>三、vertx实例化的过程</h2><p>先大致罗列下时间线</p><ul><li>1.vertx首先获取VertxFactory，获取方式有spi或编程的方式，默认是VertxFactoryImpl直接new VertxImpl();</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">VertxFactoryImpl</span> <span class="keyword">implements</span> <span class="title">VertxFactory</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> Vertx <span class="title">vertx</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> VertxImpl();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>2.根据VertxOptions配置Vertx,什么EventLoopPoolSize,workPoolSize,eventBusOptions</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">VertxImpl(VertxOptions options) &#123;</span><br><span class="line">  <span class="keyword">this</span>(options, <span class="keyword">null</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>3.看看有没有初始化Context（默认是木有的，有就报错- -）,Transport设置啥类型，默认JDK（这里还不是很理解这个东西有啥用，先挖个坑）。</li><li><p>4.启动一个checker去检测线程阻塞情况（本质是个守护线程的timer）,检测的方式很简单粗暴，内部维护一个VerxThred线程的集合，当前时间比对线程开始的执行时间，超时了就日志警告。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">BlockedThreadChecker(<span class="keyword">long</span> interval, <span class="keyword">long</span> warningExceptionTime) &#123;</span><br><span class="line">    timer = <span class="keyword">new</span> Timer(<span class="string">"vertx-blocked-thread-checker"</span>, <span class="keyword">true</span>);</span><br><span class="line">    timer.schedule(<span class="keyword">new</span> TimerTask() &#123;</span><br><span class="line">      <span class="meta">@Override</span></span><br><span class="line">      <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">synchronized</span> (BlockedThreadChecker.<span class="keyword">this</span>) &#123;</span><br><span class="line">          <span class="keyword">long</span> now = System.nanoTime();</span><br><span class="line">          <span class="keyword">for</span> (VertxThread thread : threads.keySet()) &#123;</span><br><span class="line">            <span class="keyword">long</span> execStart = thread.startTime();</span><br><span class="line">            <span class="keyword">long</span> dur = now - execStart;</span><br><span class="line">            <span class="keyword">final</span> <span class="keyword">long</span> timeLimit = thread.getMaxExecTime();</span><br><span class="line">            <span class="keyword">if</span> (execStart != <span class="number">0</span> &amp;&amp; dur &gt; timeLimit) &#123;</span><br><span class="line">              <span class="keyword">final</span> String message = <span class="string">"Thread "</span> + thread + <span class="string">" has been blocked for "</span> + (dur / <span class="number">1000000</span>) + <span class="string">" ms, time limit is "</span> + (timeLimit / <span class="number">1000000</span>);</span><br><span class="line">              <span class="keyword">if</span> (dur &lt;= warningExceptionTime) &#123;</span><br><span class="line">                log.warn(message);</span><br><span class="line">              &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                VertxException stackTrace = <span class="keyword">new</span> VertxException(<span class="string">"Thread blocked"</span>);</span><br><span class="line">                stackTrace.setStackTrace(thread.getStackTrace());</span><br><span class="line">                log.warn(message, stackTrace);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;, interval, interval);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>5.设置eventLoopGroup，这里Vertx是拿来主义，直接用netty的NioEventLoopGroup，并设置NioEventLoopGroup处理io任务的比率。（NiOEventLoopGroup的初始化过程可以看我以前netty源码分析部分），线程数默认为两倍cpu核数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventLoopGroup <span class="title">eventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, ThreadFactory threadFactory, <span class="keyword">int</span> ioRatio)</span> </span>&#123;</span><br><span class="line">   NioEventLoopGroup eventLoopGroup = <span class="keyword">new</span> NioEventLoopGroup(nThreads, threadFactory);</span><br><span class="line">   eventLoopGroup.setIoRatio(ioRatio);</span><br><span class="line">   <span class="keyword">return</span> eventLoopGroup;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>6.设置acceptorEventLoopGroup，默认是一个线程，按照源码说法在大量的请求下，如果事件循环的接受线程和上面的循环器线程在一个线程池里容易延迟。</p></li><li>7.设置VertxMetrices,这里也是以SPI的方式加载</li><li>8.默认初始化20线程的workerExec，20线程的internalBlockingExec，DeploymentManager（【重要的类】管理所有的VertxFactories,用来部署Verticles）</li><li>9.创建并开始EventBus,默认是 new EventBusImpl(this);</li><li>10.初始化ShardDataImpl</li></ul><p>现在Vertx初始化就干了这些，看起来好像啥的都没做，对，确实啥都没做，都是为后面的东西做准备。<br>进入下一节。</p><h2 id="四、vertx如何发布一个verticle"><a href="#四、vertx如何发布一个verticle" class="headerlink" title="四、vertx如何发布一个verticle"></a>四、vertx如何发布一个verticle</h2><p>带着问题去看代码，我一直都很疑惑handler是怎么异步回调的，先压下内心的疑惑，跟下去。</p><p>deployVerticle(String name)入口进入，可以看到发布Verticle这东西全部都是DeploymentManager操刀。</p><ul><li><p>1.获取Context,UUID给它随机生成一个DeployId.前面说过了，Context是与当前线程绑定的，默认情况下当前线程是没有Context的，没有的话就去生成一个EventLoopContext,看到这个名字其实很清晰。这个Context的是绑定一个EventLoop，而eventLoop本质就是个线程，没毛病。这个Context还承载了workPool,orderTaskQueue。有木有一种vertx的设计越来越清晰的感觉，我写到这是有了(<em>^▽^</em>)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deployVerticle</span><span class="params">(String identifier,</span></span></span><br><span class="line"><span class="function"><span class="params">                             DeploymentOptions options,</span></span></span><br><span class="line"><span class="function"><span class="params">                             Handler&lt;AsyncResult&lt;String&gt;&gt; completionHandler)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (options.isMultiThreaded() &amp;&amp; !options.isWorker()) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"If multi-threaded then must be worker too"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    ContextImpl callingContext = vertx.getOrCreateContext();</span><br><span class="line">    ClassLoader cl = getClassLoader(options, callingContext);</span><br><span class="line">    doDeployVerticle(identifier, generateDeploymentID(), options, callingContext, callingContext, cl, completionHandler);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>2.接着DeploymentManager做了些兼容相关的东西，根据我们传的verticle名字去判断VerticleFactory是那种类型的，加载Verticle是需不需要额外的操作啥的，我们纯洁的大java目前没有这些特殊服务，咱们略过</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (iter.hasNext()) &#123;</span><br><span class="line">      VerticleFactory verticleFactory = iter.next();</span><br><span class="line">      Future&lt;String&gt; fut = Future.future();</span><br><span class="line">      <span class="keyword">if</span> (verticleFactory.requiresResolve()) &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          verticleFactory.resolve(identifier, options, cl, fut);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">          <span class="keyword">try</span> &#123;</span><br><span class="line">            fut.fail(e);</span><br><span class="line">          &#125; <span class="keyword">catch</span> (Exception ignore) &#123;</span><br><span class="line">            <span class="comment">// Too late</span></span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        fut.complete(identifier);</span><br><span class="line">      &#125;</span><br><span class="line">      fut.setHandler(ar -&gt; &#123;&#125;);</span><br></pre></td></tr></table></figure></li><li><p>3.突然看到一个挺开心的东西，能解决上面的一个问题，handler是怎么执行的。看下面的代码，Vertx的Future在设置handler的时会先判断这个futrue有没有完成，完成了就执行handler，没有完成就继续窝着。不过这样就有了新的疑问，没完成的futrue一般保存在哪呢，总不能不管是吧。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Future&lt;T&gt; <span class="title">setHandler</span><span class="params">(Handler&lt;AsyncResult&lt;T&gt;&gt; handler)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">boolean</span> callHandler;</span><br><span class="line">   <span class="keyword">synchronized</span> (<span class="keyword">this</span>) &#123;</span><br><span class="line">     callHandler = isComplete();</span><br><span class="line">     <span class="keyword">if</span> (!callHandler) &#123;</span><br><span class="line">       <span class="keyword">this</span>.handler = handler;</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">if</span> (callHandler) &#123;</span><br><span class="line">     handler.handle(<span class="keyword">this</span>);</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></li><li><p>4.看他设置了啥handle。这里其实不怎么好分析，说的会有点绕，讲大白话就是当自己完成时，判断Verticle的名字是不是ok的，ok的话就按配置反射生成这个Verticle的实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Future&lt;T&gt; <span class="title">setHandler</span><span class="params">(Handler&lt;AsyncResult&lt;T&gt;&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//反射生成实例</span></span><br><span class="line">Verticle[] verticles = createVerticles(verticleFactory, identifier, options.getInstances(), cl);</span><br><span class="line">                doDeploy(identifier, deploymentID, options, parentContext, callingContext, completionHandler, cl, verticles);</span><br></pre></td></tr></table></figure></li><li><p>5.继续跟进doDeploy方法，</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">JsonObject conf = options.getConfig() == <span class="keyword">null</span> ? <span class="keyword">new</span> JsonObject() : options.getConfig().copy(); <span class="comment">// Copy it</span></span><br><span class="line">    String poolName = options.getWorkerPoolName();</span><br><span class="line"></span><br><span class="line">    Deployment parent = parentContext.getDeployment();</span><br><span class="line">    DeploymentImpl deployment = <span class="keyword">new</span> DeploymentImpl(parent, deploymentID, identifier, options);</span><br><span class="line"></span><br><span class="line">    AtomicInteger deployCount = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">    AtomicBoolean failureReported = <span class="keyword">new</span> AtomicBoolean();</span><br><span class="line">    <span class="keyword">for</span> (Verticle verticle: verticles) &#123;</span><br><span class="line">      WorkerExecutorImpl workerExec = poolName != <span class="keyword">null</span> ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime()) : <span class="keyword">null</span>;</span><br><span class="line">      WorkerPool pool = workerExec != <span class="keyword">null</span> ? workerExec.getPool() : <span class="keyword">null</span>;</span><br><span class="line">      ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :</span><br><span class="line">        vertx.createEventLoopContext(deploymentID, pool, conf, tccl);</span><br><span class="line"><span class="comment">//这里为每个Verticle又创建一个Context，绑定一个EventLoop,后面这个Verticle的生命周期就和这个Context绑定了</span></span><br><span class="line">      <span class="keyword">if</span> (workerExec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.addCloseHook(workerExec);</span><br><span class="line">      &#125;</span><br><span class="line">      context.setDeployment(deployment);</span><br><span class="line">      deployment.addVerticle(<span class="keyword">new</span> VerticleHolder(verticle, context));<span class="comment">//verticleHolder记录Verticle和Context绑定关系</span></span><br><span class="line">      context.runOnContext(v -&gt; &#123;<span class="comment">//verticle在Context上运行</span></span><br><span class="line">        <span class="comment">//略</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>6.其实这里就到了事件循环器的核心了,也就是netty那块的代码，以前其实分析过，现在就再来一次，也当自己复习下</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">runOnContext</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      executeAsync(task);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (RejectedExecutionException ignore) &#123;</span><br><span class="line">      <span class="comment">// Pool is already shut down</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// No metrics, we are on the event loop.</span></span><br><span class="line">    nettyEventLoop().execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, <span class="keyword">null</span>));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> Runnable <span class="title">wrapTask</span><span class="params">(ContextTask cTask, Handler&lt;Void&gt; hTask, <span class="keyword">boolean</span> checkThread, PoolMetrics metrics)</span> </span>&#123;</span><br><span class="line">...略</span><br><span class="line"><span class="comment">//将context与当前线程绑定</span></span><br><span class="line"> setContext(current, ContextImpl.<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">if</span> (cTask != <span class="keyword">null</span>) &#123;</span><br><span class="line">          cTask.run();</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          hTask.handle(<span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line">...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>7.这里有个细节，wrapTask执行任务的线程绑定了一个context。而执行任务的线程本质就是eventLoop这个SingleThreadEvenExecutor单线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> inEventLoop = <span class="keyword">this</span>.inEventLoop();</span><br><span class="line">            <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">                <span class="keyword">this</span>.addTask(task);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.startThread();<span class="comment">//当前线程要是不是这个eventLoop记录的线程就初始化线程</span></span><br><span class="line">                <span class="keyword">this</span>.addTask(task);<span class="comment">//任务加入队列，让该eventLoop的线程轮询处理</span></span><br><span class="line">                <span class="keyword">if</span> (<span class="keyword">this</span>.isShutdown() &amp;&amp; <span class="keyword">this</span>.removeTask(task)) &#123;</span><br><span class="line">                    reject();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!<span class="keyword">this</span>.addTaskWakesUp &amp;&amp; <span class="keyword">this</span>.wakesUpForTask(task)) &#123;</span><br><span class="line">                <span class="keyword">this</span>.wakeup(inEventLoop);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>8.看看startThread如何工作，先将当前线程设置为eventLoop的线程，然后开始调用NioEventLoop的run方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();</span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();<span class="comment">//这里是调用了NioEventLoop的run方法</span></span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//略略略</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>9.NioEventLoop不停轮询Selector的事件（这里我们没有起Bootstrap去监听socket，没有这些事件）,执行taskQueue里的任务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                &#125;</span><br><span class="line">                cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        runAllTasks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                    closeAll();</span><br><span class="line">                    <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li><li><p>10.从netty回到我们的Vertx，runOnContext（）,在这里可以看到我们熟悉的Verticle的init，start的方法了,</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">context.runOnContext(v -&gt; &#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">          verticle.init(vertx, context);</span><br><span class="line">          Future&lt;Void&gt; startFuture = Future.future();</span><br><span class="line">          verticle.start(startFuture);</span><br><span class="line">          startFuture.setHandler(ar -&gt; &#123;</span><br><span class="line">            <span class="keyword">if</span> (ar.succeeded()) &#123;</span><br><span class="line">              <span class="keyword">if</span> (parent != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (parent.addChild(deployment)) &#123;</span><br><span class="line">                  deployment.child = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                  <span class="comment">// Orphan</span></span><br><span class="line">                  deployment.undeploy(<span class="keyword">null</span>);</span><br><span class="line">                  <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">              &#125;</span><br><span class="line">              VertxMetrics metrics = vertx.metricsSPI();</span><br><span class="line">              <span class="keyword">if</span> (metrics != <span class="keyword">null</span>) &#123;</span><br><span class="line">                metrics.verticleDeployed(verticle);</span><br><span class="line">              &#125;</span><br><span class="line">              deployments.put(deploymentID, deployment);</span><br><span class="line">              <span class="keyword">if</span> (deployCount.incrementAndGet() == verticles.length) &#123;</span><br><span class="line">                reportSuccess(deploymentID, callingContext, completionHandler);</span><br><span class="line">              &#125;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (failureReported.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>)) &#123;</span><br><span class="line">              deployment.rollback(callingContext, completionHandler, context, ar.cause());</span><br><span class="line">            &#125;</span><br><span class="line">          &#125;);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">          <span class="keyword">if</span> (failureReported.compareAndSet(<span class="keyword">false</span>, <span class="keyword">true</span>))</span><br><span class="line">            deployment.rollback(callingContext, completionHandler, context, t);</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="五、verticle如何绑定线程"><a href="#五、verticle如何绑定线程" class="headerlink" title="五、verticle如何绑定线程"></a>五、verticle如何绑定线程</h2><p>这一节算上面两节内容的总结与再次思考</p><p>vertx实例化过程有这么几个东西(部分)：</p><ul><li>EventLoopGroup 2Xcpus Threads</li><li>WorkPool 20 Threads</li><li>AcceptorEventLoopGroup 1 Thread 这个就是给BootStrap BossGroup用的（HttpServer）</li></ul><p>发布Verticle的过程中：</p><ul><li>1.发布Verticle实例(未反射生成实例前)，生成一个Context,这个Context关联Vertx的一个EventLoop，且默认这个Context没有internalBlockingPool和workPool，这个Context主要是用来给Mertric传数据的。这个Context和Verticle没有关系。</li><li>2.生成Verticle实例后发布时，每个verticle实例都会创建一个Context(默认是EventLoopContext),context本身关联Vertx的一个EventLoop。VerticleHolder将Verticle和Context用关联起来</li><li>3.Verticle实例在它关联的Context上开始运行，并且把verticle运行的生命周期封装成一个task,在这个task中，执行的线程将context和自己绑定。这里稍微有点绕，简单的说verticle是在context的EventLoop里面执行的，这个eventLoop是单线程，verticle就相当于绑定在这个线程中。而context的作用就给这个Verticle提供运行上下文。这样就有一个问题，多个verticle绑定同一个EventLoop时，他们的Context不指定的话就线程不安全了，所以执行任务的时候又在当前线程中把属于verticle的context拿进来再次绑定。Context我们可以把它类比成ThreadLocal。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">setContext</span><span class="params">(VertxThread thread, ContextImpl context)</span> </span>&#123;</span><br><span class="line">    thread.setContext(context);</span><br><span class="line">    <span class="keyword">if</span> (!DISABLE_TCCL) &#123;</span><br><span class="line">      <span class="keyword">if</span> (context != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.setTCCL();</span><br><span class="line">      &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        Thread.currentThread().setContextClassLoader(<span class="keyword">null</span>);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li></ul><h3 id="Context的一些思考"><a href="#Context的一些思考" class="headerlink" title="Context的一些思考"></a>Context的一些思考</h3><p>前面我们知道verticle相当于是推送一个任务到eventLoop上，eventLoop内部维护一个任务队列，eventLoop自己循环去处理任务队列里的事情。这样就有问题了，要是一个任务阻塞时间太久了（这也是vertx不建议的task），不管有没有超时机制，这都会阻塞这个eventLoop处理性能。vertx肯定也考虑了这个问题，我们先看下Context的属性<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ContextImpl的一些属性</span></span><br><span class="line"> <span class="keyword">private</span> <span class="keyword">final</span> EventLoop eventLoop;</span><br><span class="line">  <span class="keyword">protected</span> VertxThread contextThread;</span><br><span class="line">  <span class="keyword">private</span> ConcurrentMap&lt;Object, Object&gt; contextData;</span><br><span class="line">  <span class="keyword">private</span> <span class="keyword">volatile</span> Handler&lt;Throwable&gt; exceptionHandler;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> WorkerPool workerPool;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> WorkerPool internalBlockingPool;</span><br><span class="line">  <span class="keyword">final</span> TaskQueue orderedTasks;</span><br><span class="line">  <span class="keyword">protected</span> <span class="keyword">final</span> TaskQueue internalOrderedTasks;</span><br></pre></td></tr></table></figure></p><p>看到里面有taskQueue和workPool,还有ConcurrentMap类型的contextData，看到这里可以大致瞎猜一下是Context用线程池去处理该阻塞任务，而这个work线程池是如何处理阻塞任务呢，我们进入下一节</p><h3 id="阻塞代码和WorkVerticle"><a href="#阻塞代码和WorkVerticle" class="headerlink" title="阻塞代码和WorkVerticle"></a>阻塞代码和WorkVerticle</h3><p>官方的API是有两种方式让我们运行阻塞代码</p><h4 id="1-vertx-executeBlocking"><a href="#1-vertx-executeBlocking" class="headerlink" title="1.vertx.executeBlocking()"></a>1.vertx.executeBlocking()</h4><p>执行阻塞代码，执行完毕异步回调结果<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//api</span></span><br><span class="line">&lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, Handler&lt;AsyncResult&lt;T&gt;&gt; resultHandler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//demo</span></span><br><span class="line">vertx.executeBlocking(future -&gt; &#123;</span><br><span class="line"><span class="comment">// Call some blocking API that takes a significant amount of time to return</span></span><br><span class="line">String result = someAPI.blockingMethod(<span class="string">"hello"</span>);</span><br><span class="line">future.complete(result);</span><br><span class="line">&#125;, res -&gt; &#123;</span><br><span class="line">System.out.println(<span class="string">"The result is: "</span> + res.result());</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p><p>跟进这个方法，我们很快就能见到老熟人Context,这个和Verticle的Context差不多。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="keyword">public</span> &lt;T&gt; <span class="function"><span class="keyword">void</span> <span class="title">executeBlocking</span><span class="params">(Handler&lt;Future&lt;T&gt;&gt; blockingCodeHandler, <span class="keyword">boolean</span> ordered,</span></span></span><br><span class="line"><span class="function"><span class="params">                                 Handler&lt;AsyncResult&lt;T&gt;&gt; asyncResultHandler)</span> </span>&#123;</span><br><span class="line">   ContextImpl context = getOrCreateContext();</span><br><span class="line">   context.executeBlocking(blockingCodeHandler, ordered, asyncResultHandler);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>后面的代码就很没劲了，还以为会是线程池啥的，结果就是vertx把这个阻塞的代码扔给起其他的eventLoop，让别的eventLoop去执行。真是偷鸡啊，个人觉得专业的活还是得专业的干，生产级别的我们还是考虑WorkVerticle吧。</p><h4 id="2-workVerticle-这里指单线程的"><a href="#2-workVerticle-这里指单线程的" class="headerlink" title="2.workVerticle(这里指单线程的)"></a>2.workVerticle(这里指单线程的)</h4><p>写个小demo作为入口</p><blockquote><p>vertx.deployVerticle(HelloWorkVerticle.class.getName(),new DeploymentOptions().setWorker(true));</p></blockquote><p>跟着方法进去其实和发布正常的Veticle一样，细微差别到这里开始体现<br>DeploymentManager.doDeploy()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">WorkerExecutorImpl workerExec = poolName != <span class="keyword">null</span> ? vertx.createSharedWorkerExecutor(poolName, options.getWorkerPoolSize(), options.getMaxWorkerExecuteTime()) : <span class="keyword">null</span>;</span><br><span class="line">      WorkerPool pool = workerExec != <span class="keyword">null</span> ? workerExec.getPool() : <span class="keyword">null</span>;</span><br><span class="line"> <span class="comment">//就这一步，根据我们的配置参数知道我们要创建一个workVerticle</span></span><br><span class="line">      ContextImpl context = options.isWorker() ? vertx.createWorkerContext(options.isMultiThreaded(), deploymentID, pool, conf, tccl) :</span><br><span class="line">        vertx.createEventLoopContext(deploymentID, pool, conf, tccl);</span><br><span class="line">      <span class="keyword">if</span> (workerExec != <span class="keyword">null</span>) &#123;</span><br><span class="line">        context.addCloseHook(workerExec);</span><br><span class="line">      &#125;</span><br><span class="line">      context.setDeployment(deployment);</span><br><span class="line">      deployment.addVerticle(<span class="keyword">new</span> VerticleHolder(verticle, context));</span><br><span class="line">      context.runOnContext(v -&gt; &#123;</span><br></pre></td></tr></table></figure></p><p>创建WorkerContext和EventLoopContext区别就是workPool了,把vertx的workPool交给了workerContext,相当于所有的workerVerticle公用这个线程池。代码一目了然<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ContextImpl <span class="title">createWorkerContext</span><span class="params">(<span class="keyword">boolean</span> multiThreaded, String deploymentID, WorkerPool workerPool, JsonObject config,</span></span></span><br><span class="line"><span class="function"><span class="params">                                         ClassLoader tccl)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (workerPool == <span class="keyword">null</span>) &#123;</span><br><span class="line">      workerPool = <span class="keyword">this</span>.workerPool;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (multiThreaded) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> MultiThreadedWorkerContext(<span class="keyword">this</span>, internalBlockingPool, workerPool, deploymentID, config, tccl);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">new</span> WorkerContext(<span class="keyword">this</span>, internalBlockingPool, workerPool, deploymentID, config, tccl);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>然后看看workerVerticle是怎么runOnContext的吧<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//WorkerContext</span></span><br><span class="line"><span class="meta">@Override</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">executeAsync</span><span class="params">(Handler&lt;Void&gt; task)</span> </span>&#123;</span><br><span class="line">    orderedTasks.execute(wrapTask(<span class="keyword">null</span>, task, <span class="keyword">true</span>, workerPool.metrics()), workerPool.executor());</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//TaskQueue</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task, Executor executor)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">      tasks.add(<span class="keyword">new</span> Task(task, executor));</span><br><span class="line">      <span class="keyword">if</span> (current == <span class="keyword">null</span>) &#123;</span><br><span class="line">        current = executor;</span><br><span class="line">        executor.execute(runner);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这里的runner在TaskQueue初始化的时候就赋了个lambda,也很简单清晰。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">final</span> Runnable runner;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="title">TaskQueue</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    runner = <span class="keyword">this</span>::run;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (; ; ) &#123;</span><br><span class="line">      <span class="keyword">final</span> Task task;</span><br><span class="line">      <span class="keyword">synchronized</span> (tasks) &#123;</span><br><span class="line">        task = tasks.poll();</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">          current = <span class="keyword">null</span>;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (task.exec != current) &#123;</span><br><span class="line">          tasks.addFirst(task);</span><br><span class="line">          task.exec.execute(runner);</span><br><span class="line">          current = task.exec;</span><br><span class="line">          <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        task.runnable.run();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">        log.error(<span class="string">"Caught unexpected Throwable"</span>, t);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p><p>总结下就是WorkerVerticle复用Vertx的workPool去执行阻塞的任务，多线程去taskQueue取任务的时候是同步的，保证了线程安全。</p><h2 id="六、verticle如何与eventBus交互"><a href="#六、verticle如何与eventBus交互" class="headerlink" title="六、verticle如何与eventBus交互"></a>六、verticle如何与eventBus交互</h2><p>挖坑</p><h2 id="七、vertx集群"><a href="#七、vertx集群" class="headerlink" title="七、vertx集群"></a>七、vertx集群</h2><p>挖坑</p>]]></content>
    
    <summary type="html">
    
      基于netty的轻量级框架
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
      <category term="vertx" scheme="http://yoursite.com/tags/vertx/"/>
    
  </entry>
  
  <entry>
    <title>分布式事务</title>
    <link href="http://yoursite.com/2018/08/03/%E5%88%86%E5%B8%83%E5%BC%8F%E4%BA%8B%E5%8A%A1/"/>
    <id>http://yoursite.com/2018/08/03/分布式事务/</id>
    <published>2018-08-03T12:15:23.000Z</published>
    <updated>2018-08-03T12:15:23.688Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>netty学习总结</title>
    <link href="http://yoursite.com/2018/07/22/netty%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/07/22/netty学习总结/</id>
    <published>2018-07-22T14:40:42.000Z</published>
    <updated>2018-08-27T02:00:48.553Z</updated>
    
    <content type="html"><![CDATA[<p>前段时间在看zuul2.0，相对于1.0是更改了netty的请求方式，还有很多新功能扩展。这段时间也有看拍拍贷内部的rpc框架，虽然是基于springMVC和Fegin http做的，不是基于netty，但是主流的rpc框架大多是由netty实现的，比如dubbo,琢磨自己给他搞成netty的练练手 ，这里就先整理下netty部分的知识。</p><blockquote><p>本文基于netty-all：4.1.6.Final，本文源码部分不是线性的去描述的，是基于某个问题一段一段的去看的，最后串成了一条线，所以可能有点跳，下次会好好整理一下。</p></blockquote><a id="more"></a><p>为什么选择netty </p><blockquote><p>高性能，基于jdk nio的<strong>异步非阻塞</strong>框架</p></blockquote><ul><li>同步 ： 相对于IO操作，在同一个时间，只能完成一个操作（JDK NIO，体现在accpet 客户端连接轮询事件时是一个线程操作）</li><li>异步 ： 相对于IO操作，在同一个时间，同时完成多个操作（JDK AIO）</li><li>阻塞 ： 相对数据操作而言，判断数据有没有准备好，如果没有准备好，则等待完成 如accpet</li><li>非阻塞： 相对数据操作而言，不管数据有没有准备好，立即获取一个反馈</li></ul><p>Bio的阻塞是在accept客户端连接阻塞的，而Nio的阻塞是在事件上阻塞的，不是说Nio是非阻塞的吗（那是对客户端请求来说是非阻塞的），而服务端对获取客户端请求的等待是阻塞的。<br>Nio中（epoll）使用了多路复用器，所以当某个客户端请求来的时候，会把该客户端连接和客户端请求事件保存到 FD事件队列，在程序中轮询select时是对有事件的channel和事件进行了轮询，他的阻塞是在select（）时阻塞的，而客户端不用同步等待服务端消息，服务端获得select（）中的事件后能立马先给客户端返回一个成功消息，将处理后的信息之后再传过去<br>这里简单提下以前的poll和select模式，其实就是selector轮询所有注册的channel是否事件准备ok，相对于epoll模式直接在一个准备就绪队列里获取事件的效率较低。1.7以后windowns也是epoll了好像，反正了解这个事情就好了，不深究了</p><p>同步阻塞 BIO<br>同步非阻塞 NIO<br>异步非阻塞 netty 、jdk AIO<br>netty相对于NIO的异步体现在加入了线程池进行操作（accpet客户端连接后轮询事件的操作丢给了线程池）</p><h3 id="高性能原因"><a href="#高性能原因" class="headerlink" title="高性能原因"></a>高性能原因</h3><h5 id="1-io模型"><a href="#1-io模型" class="headerlink" title="1.io模型"></a>1.io模型</h5><p>线程池+nio，异步非阻塞</p><h5 id="2-内存池"><a href="#2-内存池" class="headerlink" title="2.内存池"></a>2.内存池</h5><p>netty 0copy：</p><ul><li>1.直接内存缓存区，直接操作系统内存，减少了数据从jvm内存到操作系统内核的数据copy过程</li><li>2.netty提供了更强大的ByteBuf,可以组合多个ByteBuffer对象，可以像操作一个Buffer那样对组合的Buffer进行操作，避免了JDK那种需要通过内存copy的方式将几个ByteBuffer合并成一个</li><li>netty文件传输采用了transferTo的方法，可以将文件缓冲区的数据直接发送到目标channel，避免了传统的循环write()方式去进行内存copy （本质是jdk nio 的MappedBuffer 操作系统内存映射的方式）</li></ul><h5 id="3-线程模型"><a href="#3-线程模型" class="headerlink" title="3.线程模型"></a>3.线程模型</h5><p>提供了单线程，单主多从，多主从这三种线程模型,减少线程数量，调高线程利用率</p><h5 id="4-数据协议"><a href="#4-数据协议" class="headerlink" title="4.数据协议"></a>4.数据协议</h5><p>netty的ChannelHandler 编码解码为编写自定义协议提供了非常方便的流程管理，可以自定义编写些相对高效的协议</p><h3 id="源码分析的demo代码"><a href="#源码分析的demo代码" class="headerlink" title="源码分析的demo代码"></a>源码分析的demo代码</h3><p>一般我们使用netty的时候会有以下模板代码，本文打算以这个作为源码的入口进行分析，打通netty的结构和执行链路<br><em><code>本文大部分是源码分析，比较长，建议使用导航栏跳到看</code></em><br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">EventLoopGroup bossGroup = <span class="keyword">new</span> NioEventLoopGroup();</span><br><span class="line">       EventLoopGroup workerGroup = <span class="keyword">new</span> NioEventLoopGroup();  </span><br><span class="line">       <span class="keyword">try</span> &#123;  </span><br><span class="line">           ServerBootstrap b = <span class="keyword">new</span> ServerBootstrap();</span><br><span class="line">           b.group(bossGroup, workerGroup).channel(NioServerSocketChannel.class)</span><br><span class="line">                   .childHandler(<span class="keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;</span><br><span class="line">                       <span class="meta">@Override</span></span><br><span class="line">                       <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(SocketChannel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> HttpResponseEncoder());  </span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> HttpRequestDecoder()); </span><br><span class="line">                           ch.pipeline().addLast(<span class="keyword">new</span> MySelfHandler());  </span><br><span class="line">                       &#125;  </span><br><span class="line">                    &#125;).option(ChannelOption.SO_BACKLOG, <span class="number">128</span>)</span><br><span class="line">                   .childOption(ChannelOption.SO_KEEPALIVE, <span class="keyword">true</span>); </span><br><span class="line">                   </span><br><span class="line">           ChannelFuture f = b.bind(port).sync();</span><br><span class="line">           LOG.info(<span class="string">"HTTP服务已启动，监听端口:"</span> + port);</span><br><span class="line">           f.channel().closeFuture().sync();  </span><br><span class="line">           </span><br><span class="line">       &#125; <span class="keyword">finally</span> &#123;  </span><br><span class="line">           workerGroup.shutdownGracefully();  </span><br><span class="line">           bossGroup.shutdownGracefully();  </span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><h3 id="几个重要的组件"><a href="#几个重要的组件" class="headerlink" title="几个重要的组件"></a>几个重要的组件</h3><p>我们知道 JDK nio有三个重要的组件：selector、channel、buffer。<br>Netty对这几个部分做了相应封装及扩展。</p><p> Channel –&gt; NioServerSockerChannel/ NioSockerChannel Unsafe ChannelPipeline<br> ByteBuffer –&gt; ByteBuf<br> Selector –&gt; EventLoop EventLoopGroup</p><h4 id="UnSafe"><a href="#UnSafe" class="headerlink" title="UnSafe"></a>UnSafe</h4><p>jdk有个Unsafe对象，是对线程，对象字节码，内存的操作。在Netty框架里，它也设置了一个Unsafe对象，此对象封装了Java NIO底层channel的操作细节，相当于一个代理对象。而且在Netty中，每个channel都有一个unsafe对象。</p><h4 id="EventLoopGroup"><a href="#EventLoopGroup" class="headerlink" title="EventLoopGroup"></a>EventLoopGroup</h4><p>封装selector 这部分功能的组件<br>可以先看下它的类图结构<br><img src="/img/middleware/netty/source/netty_nioEventLoopGroup1.png" alt="Image text"><br>可以看到EventLoopGroup本质其实是个线程池Executor<br>从new EventLoopGroup()入口进入源码参考<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">int</span> DEFAULT_EVENT_LOOP_THREADS = Math.max(<span class="number">1</span>, SystemPropertyUtil.getInt(<span class="string">"io.netty.eventLoopThreads"</span>, Runtime.getRuntime().availableProcessors() * <span class="number">2</span>));</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventLoopGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, Object... args)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(nThreads == <span class="number">0</span> ? DEFAULT_EVENT_LOOP_THREADS : nThreads, executor, args);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>看到一个有趣的点，这个Excutor的线程数默认是2倍的cpu核数，如果手动设置了线程数量，则两者间取最大的。<br>继续跟进他的构造函数<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">MultithreadEventExecutorGroup</span><span class="params">(<span class="keyword">int</span> nThreads, Executor executor, EventExecutorChooserFactory chooserFactory, Object... args)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">this</span>.terminatedChildren = <span class="keyword">new</span> AtomicInteger();</span><br><span class="line">       <span class="keyword">this</span>.terminationFuture = <span class="keyword">new</span> DefaultPromise(GlobalEventExecutor.INSTANCE);</span><br><span class="line">       <span class="keyword">if</span> (nThreads &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(String.format(<span class="string">"nThreads: %d (expected: &gt; 0)"</span>, nThreads));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (executor == <span class="keyword">null</span>) &#123;</span><br><span class="line">               executor = <span class="keyword">new</span> ThreadPerTaskExecutor(<span class="keyword">this</span>.newDefaultThreadFactory());<span class="comment">//这个是单线程的线程池，【暂时和NioEventLoop的thread不是等价的，在singleThreadEventExecutor.doStartThread后，线程池的线程才被赋予eventLoop的thread变量】</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.children = <span class="keyword">new</span> EventExecutor[nThreads];<span class="comment">//看到这里就很清楚的知道EventLoopGroup本质是个单线程的线程池数组</span></span><br><span class="line"></span><br><span class="line">           <span class="keyword">int</span> j;</span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; nThreads; ++i) &#123;</span><br><span class="line">               <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">               <span class="keyword">boolean</span> var18 = <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">try</span> &#123;</span><br><span class="line">                   var18 = <span class="keyword">true</span>;</span><br><span class="line">                   <span class="keyword">this</span>.children[i] = <span class="keyword">this</span>.newChild((Executor)executor, args);</span><br><span class="line">                   success = <span class="keyword">true</span>;</span><br><span class="line">                   var18 = <span class="keyword">false</span>;</span><br><span class="line">               &#125; <span class="keyword">catch</span> (Exception var19) &#123;</span><br><span class="line">                   <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"failed to create a child event loop"</span>, var19);</span><br><span class="line">               &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                  <span class="comment">//省略线程关闭的代码</span></span><br><span class="line">               &#125;</span><br><span class="line"></span><br><span class="line">               <span class="keyword">if</span> (!success) &#123;</span><br><span class="line">                   <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                       <span class="keyword">this</span>.children[j].shutdownGracefully();</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">                   <span class="keyword">for</span>(j = <span class="number">0</span>; j &lt; i; ++j) &#123;</span><br><span class="line">                       EventExecutor e = <span class="keyword">this</span>.children[j];</span><br><span class="line"></span><br><span class="line">                       <span class="keyword">try</span> &#123;</span><br><span class="line">                           <span class="keyword">while</span>(!e.isTerminated()) &#123;</span><br><span class="line">                               e.awaitTermination(<span class="number">2147483647L</span>, TimeUnit.SECONDS);</span><br><span class="line">                           &#125;</span><br><span class="line">                       &#125; <span class="keyword">catch</span> (InterruptedException var22) &#123;</span><br><span class="line">                           Thread.currentThread().interrupt();</span><br><span class="line">                           <span class="keyword">break</span>;</span><br><span class="line">                       &#125;</span><br><span class="line">                   &#125;</span><br><span class="line">               &#125;</span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">this</span>.chooser = chooserFactory.newChooser(<span class="keyword">this</span>.children);<span class="comment">//step 2</span></span><br><span class="line">           FutureListener&lt;Object&gt; terminationListener = <span class="keyword">new</span> FutureListener&lt;Object&gt;() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(Future&lt;Object&gt; future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   <span class="keyword">if</span> (MultithreadEventExecutorGroup.<span class="keyword">this</span>.terminatedChildren.incrementAndGet() == MultithreadEventExecutorGroup.<span class="keyword">this</span>.children.length) &#123;<span class="comment">//step 1</span></span><br><span class="line">                       MultithreadEventExecutorGroup.<span class="keyword">this</span>.terminationFuture.setSuccess((Object)<span class="keyword">null</span>);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;;</span><br><span class="line">           EventExecutor[] arr$ = <span class="keyword">this</span>.children;</span><br><span class="line">           j = arr$.length;</span><br><span class="line"></span><br><span class="line">           <span class="keyword">for</span>(<span class="keyword">int</span> i$ = <span class="number">0</span>; i$ &lt; j; ++i$) &#123;</span><br><span class="line">               EventExecutor e = arr$[i$];</span><br><span class="line">               e.terminationFuture().addListener(terminationListener);<span class="comment">//为每个线程池添加监听器，完成时操作step 1</span></span><br><span class="line">           &#125;</span><br><span class="line"></span><br><span class="line">           Set&lt;EventExecutor&gt; childrenSet = <span class="keyword">new</span> LinkedHashSet(<span class="keyword">this</span>.children.length);</span><br><span class="line">           Collections.addAll(childrenSet, <span class="keyword">this</span>.children);</span><br><span class="line">           <span class="keyword">this</span>.readonlyChildren = Collections.unmodifiableSet(childrenSet);</span><br><span class="line">       &#125;</span><br></pre></td></tr></table></figure></p><p>这里有个小点step 2，根据executor数组的长度是否是2的次幂来选择初始化选择器的策略。以前面试的时候还被别人问过，判断一个数是否是2的次幂<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> EventExecutorChooser <span class="title">newChooser</span><span class="params">(EventExecutor[] executors)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (EventExecutorChooser)(isPowerOfTwo(executors.length) ? <span class="keyword">new</span> DefaultEventExecutorChooserFactory.PowerOfTowEventExecutorChooser(executors) : <span class="keyword">new</span> DefaultEventExecutorChooserFactory.GenericEventExecutorChooser(executors));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">boolean</span> <span class="title">isPowerOfTwo</span><span class="params">(<span class="keyword">int</span> val)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (val &amp; -val) == val;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里就以-5举例<br>0000 0000 0000 0000 0000 0000 0000 0101 5的原码<br>1000 0000 0000 0000 0000 0000 0000 0101 -5的原码<br>0111 1111 1111 1111 1111 1111 1111 1010 -5的反码   （反码+1=补码）<br>0111 1111 1111 1111 1111 1111 1111 1011 -5的补码  （在计算机中，负数以原码的补码形式表达）</p><p>5 &amp; -5<br>0000 0000 0000 0000 0000 0000 0000 0101<br>0111 1111 1111 1111 1111 1111 1111 1011  =<br>0000 0000 0000 0000 0000 0000 0000 0001 !=5 所以不是2的次幂</p><p>其实还有更快速的方法去判断一个数是否是二的次幂<br>(number &amp; number - 1) == 0<br>将2的幂次方写成二进制形式后，很容易就会发现有一个特点：二进制中只有一个1，并且1后面跟了n个0； 因此问题可以转化为判断1后面是否跟了n个0就可以了。<br>如果将这个数减去1后会发现，仅有的那个1会变为0，而原来的那n个0会变为1；因此将原来的数与去减去1后的数字进行与运算后会发现为零。</p><p>上面扯远了，继续回到主线，前面知道了EventLoopGroup是一个线程池组，也知道EventLoopGroup是要封装selector的功能，但是现在问题来了，这个Selector在哪呢，现在进入NioEventLoopGroup代码<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> EventLoop <span class="title">newChild</span><span class="params">(Executor executor, Object... args)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">new</span> NioEventLoop(<span class="keyword">this</span>, executor, (SelectorProvider)args[<span class="number">0</span>], ((SelectStrategyFactory)args[<span class="number">1</span>]).newSelectStrategy(), (RejectedExecutionHandler)args[<span class="number">2</span>]);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到在填充线程池组时候，把selectorProvider扔进去了，其实生成的实例是NioEventLoop。然后根据openSelector()生成Selector实例。同时构造方法有扔进去一个线程池，这个线程池是ThreadPerTaskExecutor类型的，线程池已经初始化了一个线程，不过EventLoop的thread变量现在依旧没有初始化<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> Selector <span class="title">openSelector</span><span class="params">()</span> </span>&#123;</span><br><span class="line">      <span class="keyword">final</span> AbstractSelector selector;</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">          selector = <span class="keyword">this</span>.provider.openSelector();</span><br><span class="line">      &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">          <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"failed to open a new selector"</span>, var7);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> selector;</span><br><span class="line"><span class="comment">//省略大部分代码.....</span></span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p><p>这样大概知道netty对selector的封装</p><h5 id="EventGroup的线程模型"><a href="#EventGroup的线程模型" class="headerlink" title="EventGroup的线程模型"></a>EventGroup的线程模型</h5><p>对netty稍微了解解的都知道，netty有三种线程模型，一般我们使用的是主从模型，类似于nginx的那个一个主进程（netty可多个），下面有多个工作线程。<br>demo代码里有两个NioEventLoopGroup，这两个Group是如何体现这种模型设计呢?<br>现在进入ServerBootstrap 的group()方法：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ServerBootstrap <span class="title">group</span><span class="params">(EventLoopGroup parentGroup, EventLoopGroup childGroup)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.group(parentGroup);</span><br><span class="line">        <span class="keyword">if</span> (childGroup == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"childGroup"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">this</span>.childGroup != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"childGroup set already"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这块代码继续跟进去其实没啥意思，简单的说就是ServerBootstrap有两个成员变量group,childGrop,引用了demo代码里的两个Group。下面带着疑问继续看，两个group的线程之间是如何交互的。ServerBootstrap的启动后两个Group肯定是要开始交互了，跟进去看,首先初始化Channel和注册：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> ChannelFuture <span class="title">doBind</span><span class="params">(<span class="keyword">final</span> SocketAddress localAddress)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">final</span> ChannelFuture regFuture = <span class="keyword">this</span>.initAndRegister(); <span class="comment">// NioServerSocketChannel init and Register</span></span><br><span class="line">       <span class="keyword">final</span> Channel channel = regFuture.channel();</span><br><span class="line">       <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123; </span><br><span class="line">           <span class="keyword">return</span> regFuture;</span><br><span class="line">       &#125; <span class="keyword">else</span> <span class="keyword">if</span> (regFuture.isDone()) &#123;</span><br><span class="line">           ChannelPromise promise = channel.newPromise();</span><br><span class="line">           doBind0(regFuture, channel, localAddress, promise);<span class="comment">//底层调用jdk 的ServerSocketChannel的bind()绑定地址和端口</span></span><br><span class="line">                       <span class="keyword">return</span> promise;</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           <span class="keyword">final</span> AbstractBootstrap.PendingRegistrationPromise promise = <span class="keyword">new</span> AbstractBootstrap.PendingRegistrationPromise(channel);</span><br><span class="line">           regFuture.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">               <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                   Throwable cause = future.cause();</span><br><span class="line">                   <span class="keyword">if</span> (cause != <span class="keyword">null</span>) &#123;</span><br><span class="line">                       promise.setFailure(cause);</span><br><span class="line">                   &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                       promise.registered();</span><br><span class="line">                       AbstractBootstrap.doBind0(regFuture, channel, localAddress, promise);</span><br><span class="line">                   &#125;</span><br><span class="line"></span><br><span class="line">               &#125;</span><br><span class="line">           &#125;);</span><br><span class="line">           <span class="keyword">return</span> promise;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>进入channel的初始化和注册方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">final</span> ChannelFuture <span class="title">initAndRegister</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Channel channel = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            channel = <span class="keyword">this</span>.channelFactory.newChannel();<span class="comment">//反射获取NioServerSocketChannel</span></span><br><span class="line">            <span class="keyword">this</span>.init(channel);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel != <span class="keyword">null</span>) &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> (<span class="keyword">new</span> DefaultChannelPromise(channel, GlobalEventExecutor.INSTANCE)).setFailure(var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelFuture regFuture = <span class="keyword">this</span>.config().group().register(channel);<span class="comment">//初始化完Channel后进行注册</span></span><br><span class="line">        <span class="keyword">if</span> (regFuture.cause() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isRegistered()) &#123;</span><br><span class="line">                channel.close();</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                channel.unsafe().closeForcibly();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> regFuture;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="channel初始化"><a href="#channel初始化" class="headerlink" title="channel初始化"></a>channel初始化</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">(Channel channel)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        Map&lt;ChannelOption&lt;?&gt;, Object&gt; options = <span class="keyword">this</span>.options0();</span><br><span class="line">        <span class="keyword">synchronized</span>(options) &#123;</span><br><span class="line">            channel.config().setOptions(options);<span class="comment">//设置ServerBootStrap的配置</span></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        Map&lt;AttributeKey&lt;?&gt;, Object&gt; attrs = <span class="keyword">this</span>.attrs0();</span><br><span class="line">        <span class="keyword">synchronized</span>(attrs) &#123;</span><br><span class="line">            Iterator i$ = attrs.entrySet().iterator();</span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span>(<span class="keyword">true</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (!i$.hasNext()) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e = (Entry)i$.next();</span><br><span class="line">                AttributeKey&lt;Object&gt; key = (AttributeKey)e.getKey();</span><br><span class="line">                channel.attr(key).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        ChannelPipeline p = channel.pipeline();<span class="comment">//取出channel的ChannelPipeline （channel的ChannelPipeline初始化过程在下一节内容）</span></span><br><span class="line">        <span class="keyword">final</span> EventLoopGroup currentChildGroup = <span class="keyword">this</span>.childGroup;</span><br><span class="line">        <span class="keyword">final</span> ChannelHandler currentChildHandler = <span class="keyword">this</span>.childHandler;</span><br><span class="line">        Map var9 = <span class="keyword">this</span>.childOptions;</span><br><span class="line">        <span class="keyword">final</span> Entry[] currentChildOptions;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childOptions) &#123;</span><br><span class="line">            currentChildOptions = (Entry[])<span class="keyword">this</span>.childOptions.entrySet().toArray(newOptionArray(<span class="keyword">this</span>.childOptions.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        var9 = <span class="keyword">this</span>.childAttrs;</span><br><span class="line">        <span class="keyword">final</span> Entry[] currentChildAttrs;</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>.childAttrs) &#123;</span><br><span class="line">            currentChildAttrs = (Entry[])<span class="keyword">this</span>.childAttrs.entrySet().toArray(newAttrArray(<span class="keyword">this</span>.childAttrs.size()));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这块是ChildrenHandle加入Pipeline</span></span><br><span class="line">        p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">        <span class="comment">//这里的ch就是Ser</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>channel的初始化没有什么特别需要注意的，主要是做一些channel的配置，比如serverBootStrap对Tcp的配置。还有初始化相应的channelPipeline。后面就是对pipeline添加Handler的操作</p><p>不得不说，pipeline加入ChannelHandle的过程被封装的好恶心,中间还加入了各种回调，其实简单的过程就是pipeline 先把个匿名的ChannelInitializer对象加入pipeline链表节点。然后在chanel注册到eventLoop后回调这个匿名对象的init方法，把pipeline的handle加入链表，最后把这个ChannelInitializer从链表中删掉。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">handlerAdded</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (ctx.channel().isRegistered()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.initChannel(ctx);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">boolean</span> <span class="title">initChannel</span><span class="params">(ChannelHandlerContext ctx)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">this</span>.initMap.putIfAbsent(ctx, Boolean.TRUE) == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.initChannel(ctx.channel());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">                <span class="keyword">this</span>.exceptionCaught(ctx, var6);</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">this</span>.remove(ctx); <span class="comment">//从链表中移除</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="channel注册过程"><a href="#channel注册过程" class="headerlink" title="channel注册过程"></a>channel注册过程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(Channel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.register((ChannelPromise)(<span class="keyword">new</span> DefaultChannelPromise(channel, <span class="keyword">this</span>)));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelFuture <span class="title">register</span><span class="params">(ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(promise, <span class="string">"promise"</span>);</span><br><span class="line">        promise.channel().unsafe().register(<span class="keyword">this</span>, promise);</span><br><span class="line">        <span class="keyword">return</span> promise;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">register</span><span class="params">(EventLoop eventLoop, <span class="keyword">final</span> ChannelPromise promise)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (eventLoop == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"eventLoop"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (AbstractChannel.<span class="keyword">this</span>.isRegistered()) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"registered to an event loop already"</span>));</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (!AbstractChannel.<span class="keyword">this</span>.isCompatible(eventLoop)) &#123;</span><br><span class="line">                promise.setFailure(<span class="keyword">new</span> IllegalStateException(<span class="string">"incompatible event loop type: "</span> + eventLoop.getClass().getName()));</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                AbstractChannel.<span class="keyword">this</span>.eventLoop = eventLoop;</span><br><span class="line">                <span class="keyword">if</span> (eventLoop.inEventLoop()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.register0(promise);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        eventLoop.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                                AbstractUnsafe.<span class="keyword">this</span>.register0(promise);</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (Throwable var4) &#123;</span><br><span class="line">                        AbstractChannel.logger.warn(<span class="string">"Force-closing a channel whose registration task was not accepted by an event loop: &#123;&#125;"</span>, AbstractChannel.<span class="keyword">this</span>, var4);</span><br><span class="line">                        <span class="keyword">this</span>.closeForcibly();</span><br><span class="line">                        AbstractChannel.<span class="keyword">this</span>.closeFuture.setClosed();</span><br><span class="line">                        <span class="keyword">this</span>.safeSetFailure(promise, var4);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>前面channel初始化完成后执行this.config().group().register(channel)的操作，这个group是指masterEventLoopGroup，这步相当于channel注册到了Selector上。不过现在依旧让人很疑惑，那workEvenLoopGroup是如何执行后面的呢？</p><p>下面就继续看看netty是如何接受客户端请求后，将I/O操作分配给workLoopGroup的EventLoop的</p><p>Java NIO 是一种 Reactor 模式, 我们通过 selector 来实现 I/O 的多路复用复用. 在一开始时, 服务器端需要监听客户端的连接请求, 我们的NioServerSocketChannel初始化的时候设置了 OP_ACCEPT, 即通知 selector 我们对客户端的连接请求感兴趣.</p><p>回看前面channel初始化时有一段pipeline的addLast方法,添加了一个匿名的ChannelInitializer对象，而这个 ChannelInitializer 中添加了一个关键的 ServerBootstrapAcceptor handler.<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = ServerBootstrap.<span class="keyword">this</span>.config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;handler&#125;);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    <span class="comment">//注意这个handler ServerBootstrapAcceptor</span></span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">new</span> ServerBootstrap.ServerBootstrapAcceptor(currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs)&#125;);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;&#125;);</span><br></pre></td></tr></table></figure></p><p>查看他的构造函数,终于找到了通向workEventLoopGroup的大门有木有<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line">ServerBootstrapAcceptor(EventLoopGroup childGroup, ChannelHandler childHandler, Entry&lt;ChannelOption&lt;?&gt;, Object&gt;[] childOptions, Entry&lt;AttributeKey&lt;?&gt;, Object&gt;[] childAttrs) &#123;</span><br><span class="line">            <span class="keyword">this</span>.childGroup = childGroup;</span><br><span class="line">            <span class="keyword">this</span>.childHandler = childHandler;</span><br><span class="line">            <span class="keyword">this</span>.childOptions = childOptions;</span><br><span class="line">            <span class="keyword">this</span>.childAttrs = childAttrs;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel)msg; <span class="comment">//这里保存了一个NioSocketChannel</span></span><br><span class="line">            child.pipeline().addLast(<span class="keyword">new</span> ChannelHandler[]&#123;<span class="keyword">this</span>.childHandler&#125;);</span><br><span class="line">            Entry[] arr$ = <span class="keyword">this</span>.childOptions;</span><br><span class="line">            <span class="keyword">int</span> len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">int</span> i$;</span><br><span class="line">            Entry e;</span><br><span class="line">            <span class="keyword">for</span>(i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                e = arr$[i$];</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!child.config().setOption((ChannelOption)e.getKey(), e.getValue())) &#123;</span><br><span class="line">                        ServerBootstrap.logger.warn(<span class="string">"Unknown channel option: "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var10) &#123;</span><br><span class="line">                    ServerBootstrap.logger.warn(<span class="string">"Failed to set a channel option: "</span> + child, var10);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            arr$ = <span class="keyword">this</span>.childAttrs;</span><br><span class="line">            len$ = arr$.length;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span>(i$ = <span class="number">0</span>; i$ &lt; len$; ++i$) &#123;</span><br><span class="line">                e = arr$[i$];</span><br><span class="line">                child.attr((AttributeKey)e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//将NioSocketChannel注册到workEventLoop上面</span></span><br><span class="line">                <span class="keyword">this</span>.childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            ServerBootstrap.ServerBootstrapAcceptor.forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var9) &#123;</span><br><span class="line">                forceClose(child, var9);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>ServerBootstrapAcceptor 中的 childGroup 是构造此对象是传入的 currentChildGroup, 即我们的 workerGroup, 而 Channel 是一个 NioSocketChannel 的实例, 因此这里的 childGroup.register 就是将 workerGroup 中的摸个 EventLoop 和 NioSocketChannel 关联了. 既然这样, 那么现在的问题是, ServerBootstrapAcceptor.channelRead 方法是怎么被调用的呢? 我们大概可以知道当一个 client 连接到 server 时, Java 底层的 NIO ServerSocketChannel 会有一个 SelectionKey.OP_ACCEPT 就绪事件, 接着就会调用到 NioServerSocketChannel.doReadMessages:<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">       SocketChannel ch = <span class="keyword">this</span>.javaChannel().accept();</span><br><span class="line"></span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">               buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">               <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">           &#125;</span><br><span class="line">       &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">           logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);</span><br><span class="line"></span><br><span class="line">           <span class="keyword">try</span> &#123;</span><br><span class="line">               ch.close();</span><br><span class="line">           &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">               logger.warn(<span class="string">"Failed to close a socket."</span>, var5);</span><br><span class="line">           &#125;</span><br><span class="line">       &#125;</span><br><span class="line"></span><br><span class="line">       <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure></p><p>在 doReadMessages 中, 通过 javaChannel().accept() 获取到客户端新连接的 SocketChannel, 接着就实例化一个 NioSocketChannel, 并且传入 NioServerSocketChannel 对象(即 this), 由此可知, 我们创建的这个 NioSocketChannel 的父 Channel 就是 NioServerSocketChannel 实例 .<br>接下来就经由 Netty 的 ChannelPipeline 机制, 将读取事件逐级发送到各个 handler 中, 于是就会触发前面我们提到的 ServerBootstrapAcceptor.channelRead 方法啦，细节部分下面流程部分分析。</p><h4 id="netty工作流程"><a href="#netty工作流程" class="headerlink" title="netty工作流程"></a>netty工作流程</h4><p>经过上面一大坨的源码跟踪，可以大概捋出来netty的主从EventLoopGroup是怎么交互的了，特地画了一个图<br><img src="/img/middleware/netty/source/netty_workflow1.png" alt="Image text"><br>文字说明一下大概流程：</p><ul><li>1.ServerBootStrap在bind(port)时，先反射生成一个NioServerSocketChannel<code>（netty封装jdk nio的ServerSocketChannel对象）</code>对象，这个channel对象在构造的过程中会生成一个相应的ChannelPipeline和Unsafe对象。Pepiel添加一个ServerBootstrapAcceptor类型的Handler。</li><li>2.NioServerSocketChannel像MasterEventLoopGroup的一个EventLoopGroup<code>（其实是个封装了Selector的单线程池）</code>注册，其实本质上还是是jdk nio包里的ServerSocketChannek向JDk的Selector注册，并监听OP_ACCPECT的事件</li><li>3.客户端发起tcp连接请求，NioServerSocketChannel监听到了accpct事件。</li><li>4.监听客户端连接后，NioServerSocketChannel通过jdk的ServerSocketChannel生成一个SocketChannel,同时生成一个ChildChannelPipeline和Unsafe对象，ChildChannelPipeline添加ServerBootStrap里设置的ChildHandlers。</li><li>5.SocketChannel向WorkEventLoopGroup中的一个EventLoop注册，监听读写事件。</li><li>6.执行ChildChannelPipeline的业务handler</li></ul><p>现在还有一些细节问题不是很清楚，先列出来，后面一个个去弄清楚：</p><ul><li><code>1.netty封装的Selector事件，这些事件是如何被捕捉，及捕捉之后怎么和Channel交互的</code></li><li><code>2.ChannelPipeline是如何调用的他的handler链的</code></li></ul><h5 id="netty封装的selector事件交互"><a href="#netty封装的selector事件交互" class="headerlink" title="netty封装的selector事件交互"></a>netty封装的selector事件交互</h5><p>我们依旧从服务端的bind()开始,源码调用跟进到ServerBootstrap.init(Channel channel)部分<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br></pre></td></tr></table></figure></p><p>这里我们看到ch.eventLoop().execute(),添加了ServerBootstrapAcceptor，先暂且不管pipel是怎么addLast执行，前面我们源码并没有分析eventLoop到底是怎么execute的，现在进去看看,这里eventLoop是SingleThreadEventExecutor。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">execute</span><span class="params">(Runnable task)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (task == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException(<span class="string">"task"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">boolean</span> inEventLoop = inEventLoop();</span><br><span class="line">        <span class="keyword">if</span> (inEventLoop) &#123;</span><br><span class="line">            addTask(task);<span class="comment">//是当前线程在执行，则直接把需要执行的Runnable当做task放进队列</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            startThread();<span class="comment">//不是当前线程则开始启动线程，然后继把任务丢进队列</span></span><br><span class="line">            addTask(task);</span><br><span class="line">            <span class="keyword">if</span> (isShutdown() &amp;&amp; removeTask(task)) &#123;</span><br><span class="line">                reject();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (!addTaskWakesUp &amp;&amp; wakesUpForTask(task)) &#123;</span><br><span class="line">            wakeup(inEventLoop);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面可以看到eventLoop最终会把Runnable包装成task任务的形式放入自己的队列当中。但是我们要知道这些任务到底是怎么执行的，进入他的startThread()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (STATE_UPDATER.get(<span class="keyword">this</span>) == ST_NOT_STARTED) &#123;</span><br><span class="line">            <span class="keyword">if</span> (STATE_UPDATER.compareAndSet(<span class="keyword">this</span>, ST_NOT_STARTED, ST_STARTED)) &#123;</span><br><span class="line">                doStartThread();<span class="comment">//开始线程并且cas改变线程的状态为ST_STARTED</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doStartThread</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">assert</span> thread == <span class="keyword">null</span>;</span><br><span class="line">        executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                thread = Thread.currentThread();<span class="comment">//这一步特别重要，将executor里的线程赋给了EventLoop的thread变量，确认了执行的线程</span></span><br><span class="line">                <span class="keyword">if</span> (interrupted) &#123;</span><br><span class="line">                    thread.interrupt();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">boolean</span> success = <span class="keyword">false</span>;</span><br><span class="line">                updateLastExecutionTime();</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    SingleThreadEventExecutor.<span class="keyword">this</span>.run();<span class="comment">//这里就是Eventloop真正的轮询逻辑了</span></span><br><span class="line">                    success = <span class="keyword">true</span>;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Unexpected exception from an event executor: "</span>, t);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                   <span class="comment">//省略一些代码</span></span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的这段代码主要就做了两件事，将EventLoopp的thread变量指向Executor里的那个线程，并且让这个线程启动轮询，监听selector的各种事件。进去看看怎么轮询事件的<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="comment">//根据是否有任务还有，得出SelectStrategy的状态</span></span><br><span class="line">                <span class="keyword">switch</span> (selectStrategy.calculateStrategy(selectNowSupplier, hasTasks())) &#123;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.CONTINUE:</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    <span class="keyword">case</span> SelectStrategy.SELECT:</span><br><span class="line">                        select(wakenUp.getAndSet(<span class="keyword">false</span>));</span><br><span class="line">                        <span class="keyword">if</span> (wakenUp.get()) &#123;</span><br><span class="line">                            selector.wakeup();</span><br><span class="line">                        &#125;</span><br><span class="line">                    <span class="keyword">default</span>:</span><br><span class="line">                        <span class="comment">// fallthrough</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                cancelledKeys = <span class="number">0</span>;</span><br><span class="line">                needsToSelectAgain = <span class="keyword">false</span>;</span><br><span class="line">                <span class="keyword">final</span> <span class="keyword">int</span> ioRatio = <span class="keyword">this</span>.ioRatio;</span><br><span class="line">                <span class="keyword">if</span> (ioRatio == <span class="number">100</span>) &#123;</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        runAllTasks();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="keyword">final</span> <span class="keyword">long</span> ioStartTime = System.nanoTime();</span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        processSelectedKeys();</span><br><span class="line">                    &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                        <span class="comment">// Ensure we always run tasks.</span></span><br><span class="line">                        <span class="keyword">final</span> <span class="keyword">long</span> ioTime = System.nanoTime() - ioStartTime;</span><br><span class="line">                        runAllTasks(ioTime * (<span class="number">100</span> - ioRatio) / ioRatio);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// Always handle shutdown even if the loop processing threw an exception.</span></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (isShuttingDown()) &#123;</span><br><span class="line">                    closeAll();</span><br><span class="line">                    <span class="keyword">if</span> (confirmShutdown()) &#123;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                handleLoopException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到线程一直在轮询Select的状态，事件被封装在processSelectedKeys()中，其实看到这个方法命名大概就知道了netty是怎么监听事件了，细节我们继续<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeys</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (selectedKeys != <span class="keyword">null</span>) &#123;</span><br><span class="line">            processSelectedKeysOptimized(selectedKeys.flip());</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            processSelectedKeysPlain(selector.selectedKeys());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKeysOptimized</span><span class="params">(SelectionKey[] selectedKeys)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;; i ++) &#123;</span><br><span class="line">            <span class="keyword">final</span> SelectionKey k = selectedKeys[i];</span><br><span class="line">            <span class="keyword">if</span> (k == <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            selectedKeys[i] = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">final</span> Object a = k.attachment();<span class="comment">//从key中拿到注册的channel</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (a <span class="keyword">instanceof</span> AbstractNioChannel) &#123;</span><br><span class="line">                processSelectedKey(k, (AbstractNioChannel) a);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="meta">@SuppressWarnings</span>(<span class="string">"unchecked"</span>)</span><br><span class="line">                NioTask&lt;SelectableChannel&gt; task = (NioTask&lt;SelectableChannel&gt;) a;</span><br><span class="line">                processSelectedKey(k, task);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (needsToSelectAgain) &#123;</span><br><span class="line">                <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                    i++;</span><br><span class="line">                    <span class="keyword">if</span> (selectedKeys[i] == <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                    selectedKeys[i] = <span class="keyword">null</span>;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                selectAgain();</span><br><span class="line">                selectedKeys = <span class="keyword">this</span>.selectedKeys.flip();</span><br><span class="line">                i = -<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>selector拿到准备就绪的SelectedKey[]然后循环执行响应的事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">processSelectedKey</span><span class="params">(SelectionKey k, AbstractNioChannel ch)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AbstractNioChannel.NioUnsafe unsafe = ch.unsafe();</span><br><span class="line">        <span class="comment">//省略一些源码..</span></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> readyOps = k.readyOps();</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_CONNECT) != <span class="number">0</span>) &#123;<span class="comment">//这里就是熟悉的jdk nio的事件判断了</span></span><br><span class="line">                <span class="keyword">int</span> ops = k.interestOps();</span><br><span class="line">                ops &amp;= ~SelectionKey.OP_CONNECT;</span><br><span class="line">                k.interestOps(ops);</span><br><span class="line">                unsafe.finishConnect();<span class="comment">//netty 客户端连接时的事件回调</span></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; SelectionKey.OP_WRITE) != <span class="number">0</span>) &#123;</span><br><span class="line">                ch.unsafe().forceFlush();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> ((readyOps &amp; (SelectionKey.OP_READ | SelectionKey.OP_ACCEPT)) != <span class="number">0</span> || readyOps == <span class="number">0</span>) &#123;</span><br><span class="line">                unsafe.read();<span class="comment">//netty 读事件就绪时的事件回调</span></span><br><span class="line">                <span class="keyword">if</span> (!ch.isOpen()) &#123;</span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (CancelledKeyException ignored) &#123;</span><br><span class="line">            unsafe.close(unsafe.voidPromise());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面的代码和jdk nio逻辑基本一致，就是多了netty自己的事件回调。我们先仔细看看接受客户端连接时，netty是怎么把socketChannel注册到childEventLoop。有打断点跟源码的话其实会看到这里的readyOps=16,代表的接受连接的事件，至于为什么=16，我们可以看SelectKy源码里的值相应设定的事件：</p><ul><li>public static final int OP_READ = 1 &lt;&lt; 0; 【1】</li><li>public static final int OP_WRITE = 1 &lt;&lt; 2; 【4】</li><li>public static final int OP_CONNECT = 1 &lt;&lt; 3; 【8】</li><li>public static final int OP_ACCEPT = 1 &lt;&lt; 4; 【16】<blockquote><p>对于ServerSocketChannel来说，accept是唯一的有效操作，而对于SocketChannel来说，有效操作包括读、写和连接，另外，对于DatagramChannle，只有读写操作是有效的</p></blockquote></li></ul><p>进入unsafe.read()，这个时候unsafe是NioMessageChannel，调用的是父类AbstractNioMessageChannel.read()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">assert</span> AbstractNioMessageChannel.<span class="keyword">this</span>.eventLoop().inEventLoop();</span><br><span class="line"></span><br><span class="line">            ChannelConfig config = AbstractNioMessageChannel.<span class="keyword">this</span>.config();</span><br><span class="line">            ChannelPipeline pipeline = AbstractNioMessageChannel.<span class="keyword">this</span>.pipeline();</span><br><span class="line">            Handle allocHandle = AbstractNioMessageChannel.<span class="keyword">this</span>.unsafe().recvBufAllocHandle();</span><br><span class="line">            allocHandle.reset(config);</span><br><span class="line">            <span class="keyword">boolean</span> closed = <span class="keyword">false</span>;</span><br><span class="line">            Throwable exception = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                <span class="keyword">int</span> localRead;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">do</span> &#123;</span><br><span class="line">                        localRead = AbstractNioMessageChannel.<span class="keyword">this</span>.doReadMessages(<span class="keyword">this</span>.readBuf);<span class="comment">//read() step 1</span></span><br><span class="line">                        <span class="keyword">if</span> (localRead == <span class="number">0</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (localRead &lt; <span class="number">0</span>) &#123;</span><br><span class="line">                            closed = <span class="keyword">true</span>;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line"></span><br><span class="line">                        allocHandle.incMessagesRead(localRead);</span><br><span class="line">                    &#125; <span class="keyword">while</span>(allocHandle.continueReading());</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable var11) &#123;</span><br><span class="line">                    exception = var11;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                localRead = <span class="keyword">this</span>.readBuf.size();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; localRead; ++i) &#123;</span><br><span class="line">                    AbstractNioMessageChannel.<span class="keyword">this</span>.readPending = <span class="keyword">false</span>;</span><br><span class="line">                    pipeline.fireChannelRead(<span class="keyword">this</span>.readBuf.get(i));<span class="comment">//read() step 2 pipel处理读事件I/O</span></span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">this</span>.readBuf.clear();</span><br><span class="line">                allocHandle.readComplete();</span><br><span class="line">                pipeline.fireChannelReadComplete();<span class="comment">//read() step 3 pipel处理读事件I/O完成时的操作</span></span><br><span class="line">                <span class="keyword">if</span> (exception != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    closed = AbstractNioMessageChannel.<span class="keyword">this</span>.closeOnReadError(exception);</span><br><span class="line">                    pipeline.fireExceptionCaught(exception);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (closed) &#123;</span><br><span class="line">                    AbstractNioMessageChannel.<span class="keyword">this</span>.inputShutdown = <span class="keyword">true</span>;</span><br><span class="line">                    <span class="keyword">if</span> (AbstractNioMessageChannel.<span class="keyword">this</span>.isOpen()) &#123;</span><br><span class="line">                        <span class="keyword">this</span>.close(<span class="keyword">this</span>.voidPromise());</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> (!AbstractNioMessageChannel.<span class="keyword">this</span>.readPending &amp;&amp; !config.isAutoRead()) &#123;</span><br><span class="line">                    <span class="keyword">this</span>.removeReadOp();</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可看到read()方法开始使用ServerSocketChannel的ChannelPiple，先执行step 1 doReadMessages()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">int</span> <span class="title">doReadMessages</span><span class="params">(List&lt;Object&gt; buf)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        SocketChannel ch = <span class="keyword">this</span>.javaChannel().accept();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (ch != <span class="keyword">null</span>) &#123;</span><br><span class="line">                buf.add(<span class="keyword">new</span> NioSocketChannel(<span class="keyword">this</span>, ch));</span><br><span class="line">                <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var6) &#123;</span><br><span class="line">            logger.warn(<span class="string">"Failed to create a new channel from an accepted socket."</span>, var6);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable var5) &#123;</span><br><span class="line">                logger.warn(<span class="string">"Failed to close a socket."</span>, var5);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里知道NioServerSocketChannel接受连接本质还是使用了jdk ServerSocketChannel的accept()，生成了一个SocketChannel ,并封装成Netty的NioSocketChannel，指定netty的NioServerSocketChannel为他的父Channel。</p><p><code>这里其实疑问点，为什么这里循环两次doMessage，生成了两个NioSocketChannel</code>,先记着</p><p>生成NioSocketChannel后，NioServerSocketChannel用开始调用pipeline的ChannelHandle处理read事件<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">final</span> ChannelPipeline <span class="title">fireChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext.invokeChannelRead(head, msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>这里开始从头节点执行ChannelRead事件，继续深入调用链<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(<span class="keyword">final</span> AbstractChannelHandlerContext next, Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> Object m = next.pipeline.touch(ObjectUtil.checkNotNull(msg, <span class="string">"msg"</span>), next);</span><br><span class="line">        EventExecutor executor = next.executor();</span><br><span class="line">        <span class="keyword">if</span> (executor.inEventLoop()) &#123;</span><br><span class="line">            next.invokeChannelRead(m);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            executor.execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                <span class="meta">@Override</span></span><br><span class="line">                <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                    next.invokeChannelRead(m);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>上面已经说了next其实是pepel的头节点，((ChannelInboundHandler) handler()).channelRead(this, msg)其实使用的是headContex的重写的channelRead方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">            ctx.fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>跟进去，又调回AbstractChannelHandlerContext的fireChannelRead<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ChannelHandlerContext <span class="title">fireChannelRead</span><span class="params">(<span class="keyword">final</span> Object msg)</span> </span>&#123;</span><br><span class="line">        invokeChannelRead(findContextInbound(), msg);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">findContextInbound</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        AbstractChannelHandlerContext ctx = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">do</span> &#123;</span><br><span class="line">            ctx = ctx.next;</span><br><span class="line">        &#125; <span class="keyword">while</span> (!ctx.inbound);</span><br><span class="line">        <span class="comment">//从头结点往后找，直到找到inbound类型的Handler，这里其实是NioServerSocketChannel ChannelPipel里添加的ServerBootStrapAcceptor</span></span><br><span class="line">        <span class="keyword">return</span> ctx;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">invokeChannelRead</span><span class="params">(Object msg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (invokeHandler()) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ((ChannelInboundHandler) handler()).channelRead(<span class="keyword">this</span>, msg);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                notifyHandlerException(t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            fireChannelRead(msg);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>然后执行ServerBootStrapAcceptor的channelRead()<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">final</span> Channel child = (Channel) msg;</span><br><span class="line"></span><br><span class="line">            child.pipeline().addLast(childHandler);</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;ChannelOption&lt;?&gt;, Object&gt; e: childOptions) &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!child.config().setOption((ChannelOption&lt;Object&gt;) e.getKey(), e.getValue())) &#123;</span><br><span class="line">                        logger.warn(<span class="string">"Unknown channel option: "</span> + e);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to set a channel option: "</span> + child, t);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">for</span> (Entry&lt;AttributeKey&lt;?&gt;, Object&gt; e: childAttrs) &#123;</span><br><span class="line">                child.attr((AttributeKey&lt;Object&gt;) e.getKey()).set(e.getValue());</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                childGroup.register(child).addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!future.isSuccess()) &#123;</span><br><span class="line">                            forceClose(child, future.cause());</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Throwable t) &#123;</span><br><span class="line">                forceClose(child, t);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>看到这里不陌生了，我们前面也分析过这段代码，这里就是将NioSocketChannel注册到childEventLoop的Selector上面，然后后面的执行逻辑其实和MasterEventLoop差不多，简单的说就是childEventLoop里的线程也一直轮询注册的NioSocketChannels传递过来的事件(这里也是netty高性能的原因之一，一个eventLoop被多个channel注册)，其实主要是read和write事件,然后回调NioSocketChannel里的ChannelPipeline的ChannelRead/write等方法，链式执行里面的各种handler。</p><p>下面来分析下ChannelPipeline的处理流程。</p><h4 id="ChannelPipeline"><a href="#ChannelPipeline" class="headerlink" title="ChannelPipeline"></a>ChannelPipeline</h4><p>channel扩展了功能处理，netty自己为每个channel对应了一个ChannelPieple</p><h5 id="channelPieple实例初始化"><a href="#channelPieple实例初始化" class="headerlink" title="channelPieple实例初始化"></a>channelPieple实例初始化</h5><p>签名boosEventLoopGroup反射生成一个NioServerSocketChannel时，看它的构造过程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">()</span> </span>&#123; <span class="comment">//step 1 无参构造</span></span><br><span class="line">        <span class="keyword">this</span>(newSocket(DEFAULT_SELECTOR_PROVIDER));</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> java.nio.channels.<span class="function">ServerSocketChannel <span class="title">newSocket</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> provider.openServerSocketChannel(); <span class="comment">//step 2 生成一个NioServerSocketChannel</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var2) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to open a server socket."</span>, var2);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(SelectorProvider provider)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>(newSocket(provider));<span class="comment">// step 3  调用有参构造</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">NioServerSocketChannel</span><span class="params">(java.nio.channels.ServerSocketChannel channel)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>((Channel)<span class="keyword">null</span>, channel, <span class="number">16</span>); <span class="comment">//step 4 调用父类方法的构造函数</span></span><br><span class="line">        <span class="keyword">this</span>.config = <span class="keyword">new</span> NioServerSocketChannel.NioServerSocketChannelConfig(<span class="keyword">this</span>, <span class="keyword">this</span>.javaChannel().socket());</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//这里构造器很重要，相当于将jdk的NIO Channel通道封装进入了Netty的Channel通道</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractNioChannel</span><span class="params">(Channel parent, SelectableChannel ch, <span class="keyword">int</span> readInterestOp)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>(parent);</span><br><span class="line">        <span class="keyword">this</span>.ch = ch; <span class="comment">//[这里保存jdk的nio serverChannel!!]NioServerSocketChannel是Netty的</span></span><br><span class="line">        <span class="keyword">this</span>.readInterestOp = readInterestOp; <span class="comment">//设置设置ServerSocketChannel关心的事件类型,这里是指只监听OP_ACCPET的事件，因为一开始Selector也只接受这个事件</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            ch.configureBlocking(<span class="keyword">false</span>); <span class="comment">//设置jdk nio为非阻塞的</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException var7) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                ch.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException var6) &#123;</span><br><span class="line">                <span class="keyword">if</span> (logger.isWarnEnabled()) &#123;</span><br><span class="line">                    logger.warn(<span class="string">"Failed to close a partially initialized socket."</span>, var6);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> ChannelException(<span class="string">"Failed to enter non-blocking mode."</span>, var7);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">AbstractChannel</span><span class="params">(Channel parent)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.parent = parent;</span><br><span class="line">        <span class="keyword">this</span>.id = <span class="keyword">this</span>.newId();</span><br><span class="line">        <span class="keyword">this</span>.unsafe = <span class="keyword">this</span>.newUnsafe();<span class="comment">//每一个channel都有一个折翼的Unsafe</span></span><br><span class="line">        <span class="keyword">this</span>.pipeline = <span class="keyword">this</span>.newChannelPipeline(); <span class="comment">//step5 跟进父类构造函数可以看到 这里初始化了一个ChannelPieple</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="title">DefaultChannelPipeline</span><span class="params">(Channel channel)</span> </span>&#123; <span class="comment">//step 6 pipel的构造过程</span></span><br><span class="line">        <span class="keyword">this</span>.channel = (Channel)ObjectUtil.checkNotNull(channel, <span class="string">"channel"</span>);</span><br><span class="line">        <span class="keyword">this</span>.succeededFuture = <span class="keyword">new</span> SucceededChannelFuture(channel, (EventExecutor)<span class="keyword">null</span>);</span><br><span class="line">        <span class="keyword">this</span>.voidPromise = <span class="keyword">new</span> VoidChannelPromise(channel, <span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">this</span>.tail = <span class="keyword">new</span> DefaultChannelPipeline.TailContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.head = <span class="keyword">new</span> DefaultChannelPipeline.HeadContext(<span class="keyword">this</span>);</span><br><span class="line">        <span class="keyword">this</span>.head.next = <span class="keyword">this</span>.tail;</span><br><span class="line">        <span class="keyword">this</span>.tail.prev = <span class="keyword">this</span>.head;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>可以看到ChannelPipeline本质是个双向链表，有AbstractChannelHandlerContext类型的tail和head链表节点。看AbstractChannelHandlerContext的类结构，它本身也是个channelHandle。不过在使用过程中，context的是handler的上下文，相当于handler的容器。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> AbstractChannelHandlerContext <span class="title">newContext</span><span class="params">(EventExecutorGroup group, String name, ChannelHandler handler)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> DefaultChannelHandlerContext(<span class="keyword">this</span>, <span class="keyword">this</span>.childExecutor(group), name, handler);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="pipeline里的ChannelInitializer"><a href="#pipeline里的ChannelInitializer" class="headerlink" title="pipeline里的ChannelInitializer"></a>pipeline里的ChannelInitializer</h5><p>pipeline链路的初始化是基于这个类的，其实这个的初始化还是比较简单，也就不贴netty代码了，贴下执行链路</p><ul><li>pipeline.addLast(ChannelInitializer)</li><li>–&gt;DefaultChannelPipeline.addLast(null, handlers);</li><li>–&gt;DefaultChannelPipeline.addLast(null, handlers) –&gt;addLast(EventExecutorGroup group, String name, ChannelHandler handler)</li><li>–&gt;addLast0(AbstractChannelHandlerContext newCtx)  ChannelInitializer加入链路</li><li>–&gt;callHandlerAdded0(newCtx);</li><li>–&gt;ChannelInitializer.handlerAdded(ctx)</li><li>–&gt;ChannelInitializer.initChannel(ctx) //最终调用定义的initChannel()方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">p.addLast(<span class="keyword">new</span> ChannelInitializer&lt;Channel&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">initChannel</span><span class="params">(Channel ch)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">                <span class="keyword">final</span> ChannelPipeline pipeline = ch.pipeline();</span><br><span class="line">                ChannelHandler handler = config.handler();</span><br><span class="line">                <span class="keyword">if</span> (handler != <span class="keyword">null</span>) &#123;</span><br><span class="line">                    pipeline.addLast(handler);</span><br><span class="line">                &#125;</span><br><span class="line">                ch.eventLoop().execute(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                        pipeline.addLast(<span class="keyword">new</span> ServerBootstrapAcceptor(</span><br><span class="line">                                currentChildGroup, currentChildHandler, currentChildOptions, currentChildAttrs));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br></pre></td></tr></table></figure></li></ul><p>这里面也把线程的执行串起来了，netty的工作流程在这里可以说已经通路了</p><h5 id="pipeline执行流程"><a href="#pipeline执行流程" class="headerlink" title="pipeline执行流程"></a>pipeline执行流程</h5><p>其实上面的源码分析，很多已经涉及到了pipeline的执行流程，这里就简单回顾下，pipeline的执行始于eventLoop对Seletor事件的回调，然后pipeline根据是出站还是进站事件从头节点到尾节点，或是尾节点到头结点、</p><h4 id="ChannelFutrue-ChannelPromise"><a href="#ChannelFutrue-ChannelPromise" class="headerlink" title="ChannelFutrue |  ChannelPromise"></a>ChannelFutrue |  ChannelPromise</h4><h5 id="netty的channel"><a href="#netty的channel" class="headerlink" title="netty的channel"></a>netty的channel</h5><p>这个本来应该放在前面讲的，先不管排版了- -！这部分内容也比较简单，是引用别人总结的<br>Netty的Channel相对于jdk的channel多了些扩展，除了jdk NIO中Channel所包含的网络I/O操作,主动建立/关闭连接,获取双方网络地址的功能外,还包含了Netty框架的功能,例如:获取Channel的EventLoop\Pipeline等。</p><ul><li>Channel接口是能与一个网络套接字(或组件)进行I/0操作(读取\写入\连接\绑定)的纽带.</li><li>通过Channel可以获取连接的状态(是否连接/是否打开),配置通道的参数(设置缓冲区大小等),进行I/O操作</li></ul><h5 id="channel-的释放"><a href="#channel-的释放" class="headerlink" title="channel 的释放"></a>channel 的释放</h5><p>当Channel完成工作后,需要调用ChannelOutboundInvoker.close()或ChannelOutboundInvoker.close(ChannelPromise)释放所有资源.这样做是为了确保所有资源(文件句柄)都能够得到释放</p><h5 id="channelFuture"><a href="#channelFuture" class="headerlink" title="channelFuture"></a>channelFuture</h5><p>channelFuture是为了在异步操作时，获取channel（状态）结果的的扩展<br>ChannelFuture有两种状态:未完成(uncompleted)和完成(completed).<br>当令Channel开始一个I/O操作时,会创建一个新的ChannelFuture去异步完成操作.<br>被创建时的ChannelFuture处于uncompleted状态(非失败,非成功,非取消);一旦ChannelFuture完成I/O操作,ChannelFuture将处于completed状态,结果可能有三种: </p><ul><li>成功</li><li>失败</li><li>取消（I/O操作被终止）</li></ul><p>netty里面关于channelFuture的状态图如下：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">                                    +---------------------------+</span><br><span class="line">                                     | Completed successfully    |</span><br><span class="line">                                     +---------------------------+</span><br><span class="line">                                +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">+--------------------------+    |    |   isSuccess() = <span class="keyword">true</span>      |</span><br><span class="line">|        Uncompleted       |    |    +===========================+</span><br><span class="line">+--------------------------+    |    | Completed with failure    |</span><br><span class="line">|      isDone() = <span class="keyword">false</span>    |    |    +---------------------------+</span><br><span class="line">|   isSuccess() = <span class="keyword">false</span>    |----+----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">| isCancelled() = <span class="keyword">false</span>    |    |    |       cause() = non-<span class="keyword">null</span>  |</span><br><span class="line">|       cause() = <span class="keyword">null</span>     |    |    +===========================+</span><br><span class="line">+--------------------------+    |    | Completed by cancellation |</span><br><span class="line">                                |    +---------------------------+</span><br><span class="line">                                +----&gt;      isDone() = <span class="keyword">true</span>      |</span><br><span class="line">                                     | isCancelled() = <span class="keyword">true</span>      |</span><br><span class="line">                                     +---------------------------+</span><br></pre></td></tr></table></figure></p><p>channelFuture和channelPromise的区别简单的说就是一个可以设置返回值，其实两个是成对出现的</p><p>还有回调部分的扩展</p><h5 id="GenericFutureListener"><a href="#GenericFutureListener" class="headerlink" title="GenericFutureListener"></a>GenericFutureListener</h5><p>虽然可以通过ChannelFuture的get()方法获取异步操作的结果,但完成时间是无法预测的,若不设置超时时间则有可能导致线程长时间被阻塞;若是不能精确的设置超时时间则可能导致I/O操作中断.因此,Netty建议通过GenericFutureListener接口执行异步操作结束后的回调.</p><p>netty添加回调的示例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">channelRead</span><span class="params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;</span><br><span class="line">     ChannelFuture future = ctx.channel().close();</span><br><span class="line">     future.addListener(<span class="keyword">new</span> ChannelFutureListener() &#123;</span><br><span class="line">         <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">operationComplete</span><span class="params">(ChannelFuture future)</span> </span>&#123;</span><br><span class="line">             <span class="comment">// Perform post-closure operation</span></span><br><span class="line">             <span class="comment">// ...</span></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure></p><p>netty中调用监听的部分源码示例:ChannelPromise<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultChannelPromise</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> ChannelPromise <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> Void&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.addListener(listener);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">//super是DefaultPromise</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">addListener</span><span class="params">(GenericFutureListener&lt;? extends Future&lt;? <span class="keyword">super</span> V&gt;&gt; listener)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(listener, <span class="string">"listener"</span>);</span><br><span class="line">        <span class="keyword">synchronized</span>(<span class="keyword">this</span>) &#123;</span><br><span class="line">            <span class="keyword">this</span>.addListener0(listener);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.isDone()) &#123;</span><br><span class="line">            <span class="keyword">this</span>.notifyListeners();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="comment">//DefaultPromise来执行回调</span></span><br><span class="line"><span class="function"><span class="keyword">protected</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener</span><span class="params">(EventExecutor eventExecutor, Future&lt;?&gt; future, GenericFutureListener&lt;?&gt; listener)</span> </span>&#123;</span><br><span class="line">        ObjectUtil.checkNotNull(eventExecutor, <span class="string">"eventExecutor"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(future, <span class="string">"future"</span>);</span><br><span class="line">        ObjectUtil.checkNotNull(listener, <span class="string">"listener"</span>);</span><br><span class="line">        notifyListenerWithStackOverFlowProtection(eventExecutor, future, listener);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListenerWithStackOverFlowProtection</span><span class="params">(EventExecutor executor, <span class="keyword">final</span> Future&lt;?&gt; future, <span class="keyword">final</span> GenericFutureListener&lt;?&gt; listener)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(executor.inEventLoop()) &#123;</span><br><span class="line">            InternalThreadLocalMap threadLocals = InternalThreadLocalMap.get();</span><br><span class="line">            <span class="keyword">int</span> stackDepth = threadLocals.futureListenerStackDepth();</span><br><span class="line">            <span class="keyword">if</span>(stackDepth &lt; MAX_LISTENER_STACK_DEPTH) &#123;</span><br><span class="line">                threadLocals.setFutureListenerStackDepth(stackDepth + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    notifyListener0(future, listener);</span><br><span class="line">                &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">                    threadLocals.setFutureListenerStackDepth(stackDepth);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        safeExecute(executor, <span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">                DefaultPromise.notifyListener0(future, listener);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">notifyListener0</span><span class="params">(Future future, GenericFutureListener l)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            l.operationComplete(future);<span class="comment">//执行我们定义的回调方法</span></span><br><span class="line">        &#125; <span class="keyword">catch</span> (Throwable var3) &#123;</span><br><span class="line">            logger.warn(<span class="string">"An exception was thrown by "</span> + l.getClass().getName() + <span class="string">".operationComplete()"</span>, var3);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>addListener(GenericFutureListener)是非阻塞的。它会把特定的ChannelFutureListener添加到ChannelFuture中，然后I/O线程会在I/O操作相关的future完成的时候通知监听器。ChannelFutureListener会利于最佳的性能和资源的利用，因为它一点阻塞都没有。然而，如果你不使用基于事件驱动的编程方式，去实现一个后续式的逻辑会变得诡异和难于理解。</p><p>具体什么时候执行回调，是在状态改变的时候，比如完成成功时<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//DefaultPromise</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Promise&lt;V&gt; <span class="title">setSuccess</span><span class="params">(V result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">this</span>.setSuccess0(result)) &#123;</span><br><span class="line">            <span class="keyword">this</span>.notifyListeners();</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">"complete already: "</span> + <span class="keyword">this</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="一些小问题"><a href="#一些小问题" class="headerlink" title="一些小问题"></a>一些小问题</h3><h4 id="拆包与粘包"><a href="#拆包与粘包" class="headerlink" title="拆包与粘包"></a>拆包与粘包</h4><p>tcp是一个二进制字节码流的协议，所谓流就是没有界限的概念。作为传输层并不理解上层协议业务数据的含义，他会根据tcp缓冲区的实际情况进行包的划分，但是在业务上被认为是一个完成的数据包。比如一个数据包被tcp分作多次发送，或是多个数据包封装成一个发送。这就是拆包和粘包</p><h4 id="解决策略"><a href="#解决策略" class="headerlink" title="解决策略"></a>解决策略</h4><ul><li>消息定长，比如报文固定1024字节，不够的空格补齐</li><li>包尾添加特殊分隔符，比如ftp协议，每条报文结束都添加回车换行符。接收方通过特殊分隔符切分报文</li><li>将消息分为消息头额消息体。消息头包含消息体的总长度</li><li>自定义应用层协议</li></ul><blockquote><p>netty的编码解码handler就相当于tcp的拆包粘包的过程</p></blockquote><h4 id="参考相关"><a href="#参考相关" class="headerlink" title="参考相关"></a>参考相关</h4><p><a href="https://segmentfault.com/a/1190000006824196" target="_blank" rel="noopener">https://segmentfault.com/a/1190000006824196</a><br><a href="https://segmentfault.com/a/1190000007283053" target="_blank" rel="noopener">https://segmentfault.com/a/1190000007283053</a><br><a href="https://blog.csdn.net/wbbhao/article/details/78943624" target="_blank" rel="noopener">https://blog.csdn.net/wbbhao/article/details/78943624</a><br><a href="https://blog.csdn.net/wbbhao/article/details/78943567" target="_blank" rel="noopener">https://blog.csdn.net/wbbhao/article/details/78943567</a><br><a href="https://www.jianshu.com/p/d94b6350ddaa（nio各组件）" target="_blank" rel="noopener">https://www.jianshu.com/p/d94b6350ddaa（nio各组件）</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;前段时间在看zuul2.0，相对于1.0是更改了netty的请求方式，还有很多新功能扩展。这段时间也有看拍拍贷内部的rpc框架，虽然是基于springMVC和Fegin http做的，不是基于netty，但是主流的rpc框架大多是由netty实现的，比如dubbo,琢磨自己给他搞成netty的练练手 ，这里就先整理下netty部分的知识。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;本文基于netty-all：4.1.6.Final，本文源码部分不是线性的去描述的，是基于某个问题一段一段的去看的，最后串成了一条线，所以可能有点跳，下次会好好整理一下。&lt;/p&gt;
&lt;/blockquote&gt;
    
    </summary>
    
      <category term="netty" scheme="http://yoursite.com/categories/netty/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="nio" scheme="http://yoursite.com/tags/nio/"/>
    
      <category term="netty" scheme="http://yoursite.com/tags/netty/"/>
    
  </entry>
  
  <entry>
    <title>无锁数据结构-队列，栈</title>
    <link href="http://yoursite.com/2018/07/11/%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%98%9F%E5%88%97%EF%BC%8C%E6%A0%88/"/>
    <id>http://yoursite.com/2018/07/11/无锁数据结构-队列，栈/</id>
    <published>2018-07-10T16:01:18.000Z</published>
    <updated>2018-07-14T07:27:37.537Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>无锁数据结构-链表</title>
    <link href="http://yoursite.com/2018/07/11/%E6%97%A0%E9%94%81%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84-%E9%93%BE%E8%A1%A8/"/>
    <id>http://yoursite.com/2018/07/11/无锁数据结构-链表/</id>
    <published>2018-07-10T16:00:45.000Z</published>
    <updated>2018-07-14T07:27:37.537Z</updated>
    
    <summary type="html">
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>致两千年后的你</title>
    <link href="http://yoursite.com/2018/07/07/%E8%87%B4%E4%B8%A4%E5%8D%83%E5%B9%B4%E5%90%8E%E7%9A%84%E4%BD%A0/"/>
    <id>http://yoursite.com/2018/07/07/致两千年后的你/</id>
    <published>2018-07-07T09:08:20.000Z</published>
    <updated>2018-07-14T07:27:37.537Z</updated>
    
    <content type="html"><![CDATA[<p>云是风的故事，要很轻很轻才行</p><p><img src="/img/essay/emotion/sanli.jpg" alt="Image text"></p>]]></content>
    
    <summary type="html">
    
      sanli
    
    </summary>
    
      <category term="emotion" scheme="http://yoursite.com/categories/emotion/"/>
    
    
      <category term="随笔" scheme="http://yoursite.com/tags/%E9%9A%8F%E7%AC%94/"/>
    
      <category term="emotion" scheme="http://yoursite.com/tags/emotion/"/>
    
      <category term="wait" scheme="http://yoursite.com/tags/wait/"/>
    
  </entry>
  
  <entry>
    <title>AQS应用-Semaphore解析</title>
    <link href="http://yoursite.com/2018/06/30/AQS%E5%BA%94%E7%94%A8-Semaphore%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/30/AQS应用-Semaphore解析/</id>
    <published>2018-06-30T15:29:00.000Z</published>
    <updated>2018-07-14T07:30:29.469Z</updated>
    
    <content type="html"><![CDATA[<h3 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h3><h4 id="网关限流"><a href="#网关限流" class="headerlink" title="网关限流"></a>网关限流</h4><h3 id="分布式信号量"><a href="#分布式信号量" class="headerlink" title="分布式信号量"></a>分布式信号量</h3>]]></content>
    
    <summary type="html">
    
      摘要,Semaphore源码解析
    
    </summary>
    
      <category term="j.u.c" scheme="http://yoursite.com/categories/j-u-c/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="j.u.c" scheme="http://yoursite.com/tags/j-u-c/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>AQS 源码解析</title>
    <link href="http://yoursite.com/2018/06/30/AQS-%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <id>http://yoursite.com/2018/06/30/AQS-源码解析/</id>
    <published>2018-06-30T15:25:56.000Z</published>
    <updated>2019-01-25T08:42:10.386Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、引言"><a href="#一、引言" class="headerlink" title="一、引言"></a>一、引言</h3><blockquote><p> <strong>AQS(AbstractQueuedSynchronizer):  </strong>JDK下提供的一套用于实现基于FIFO等待队列的阻塞锁和相关的同步器的一个同步框架<br><a id="more"></a></p></blockquote><h4 id="与synchronizer对比"><a href="#与synchronizer对比" class="headerlink" title="与synchronizer对比"></a>与synchronizer对比</h4><h4 id="synchronizer："><a href="#synchronizer：" class="headerlink" title="synchronizer："></a>synchronizer：</h4><p><strong>优点：</strong>可以花最小的空间开销创建锁（因为每个JAVA对象或者类都可以作为锁使用）和最少的时间开销获得锁（单线程可以在最短时间内获得锁）。线程同步越来越多地被用在多处理器上<br><strong>缺点：</strong>在高并发的情况下，synchronizer表现一般，而且不支持任何公平策略。</p><p>于是从JAVA 5开始在java.util.concurrent包中引入了有别于Synchronized的同步框架AQS。</p><h4 id="AQS："><a href="#AQS：" class="headerlink" title="AQS："></a>AQS：</h4><p><strong>优点：</strong> 提高了扩展性，用户可自定义同步类、提高吞吐量、提供公平策略及响应中断。<br><strong>缺点：</strong> 增加了空间开销</p><h3 id="二、AQS原理"><a href="#二、AQS原理" class="headerlink" title="二、AQS原理"></a>二、AQS原理</h3><p>　　同步框架最重要的是要有一个同步队列，在这里被严格限制为FIFO队列，因此这个同步框架不支持基于优先级的同步策略。</p><p>　　队列锁的优点是：进出队快，无锁，畅通无阻（即使在有竞争的情况下，总有一个线程总是能够很快插入到队尾）；检查是否有线程在等待也是很容易的（只需要检查头尾指针是否相同）。</p><p>　　而非阻塞队列只有两个可供选择：<strong>CLH队列锁</strong>和<strong>MCS队列锁</strong>。</p><h4 id="CLH-lock"><a href="#CLH-lock" class="headerlink" title="CLH lock"></a>CLH lock</h4><blockquote><p>CLH锁是一种基于链表的可扩展、高性能、公平的自旋锁. 申请线程只在<strong>前驱节点的本地变量上自旋</strong>，它不断轮询前驱的状态，如果发现前驱释放了锁就结束自旋。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">CLHNode</span> </span>&#123;</span><br><span class="line">        <span class="keyword">private</span> <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>; <span class="comment">// 默认是在等待锁</span></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">volatile</span> CLHNode tail;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;CLHLock, CLHNode&gt; UPDATER = AtomicReferenceFieldUpdater</span><br><span class="line">            .newUpdater(CLHLock.class, CLHNode.class, <span class="string">"tail"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(CLHNode currentThreadCLHNode)</span> </span>&#123;</span><br><span class="line">        CLHNode preNode = UPDATER.getAndSet(<span class="keyword">this</span>, currentThreadCLHNode); <span class="comment">//"tail" 值设置成currentThreadCLHNode</span></span><br><span class="line">        <span class="keyword">if</span> (preNode != <span class="keyword">null</span>) &#123;<span class="comment">//前面节点在等待锁,说明已有线程占用了锁，进入自旋</span></span><br><span class="line">            <span class="keyword">while</span> (preNode.isLocked) &#123;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(CLHNode currentThreadCLHNode)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 如果队列里只有当前线程，则释放对当前线程的引用（for GC）。</span></span><br><span class="line">        <span class="keyword">if</span> (!UPDATER.compareAndSet(<span class="keyword">this</span>, currentThreadCLHNode, <span class="keyword">null</span>)) &#123;</span><br><span class="line">            <span class="comment">// 还有后续线程</span></span><br><span class="line">            currentThreadCLHNode.isLocked = <span class="keyword">false</span>;<span class="comment">// 改变状态，让后续线程结束自旋</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="MCS-lock"><a href="#MCS-lock" class="headerlink" title="MCS lock"></a>MCS lock</h4><blockquote><p>MCS锁也是一种基于链表的可扩展、高性能、公平的自旋锁，相对于CLH,申请线程只在<strong>当前节点的本地变量上自旋</strong>，当前节点释放锁后通知后续节点结束自旋，从而极大地减少了不必要的处理器缓存同步的次数，降低了总线和内存的开销.</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> java.util.concurrent.atomic.AtomicReferenceFieldUpdater;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSLock</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="class"><span class="keyword">class</span> <span class="title">MCSNode</span> </span>&#123;</span><br><span class="line">        MCSNode next;</span><br><span class="line">        <span class="keyword">boolean</span> isLocked = <span class="keyword">true</span>; <span class="comment">// 默认是在等待锁</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">volatile</span> MCSNode queue;<span class="comment">// 指向最后一个申请锁的MCSNode</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> AtomicReferenceFieldUpdater&lt;MCSLock, MCSNode&gt; UPDATER = AtomicReferenceFieldUpdater</span><br><span class="line">            .newUpdater(MCSLock.class, MCSNode.class, <span class="string">"queue"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">lock</span><span class="params">(MCSNode currentThreadMcsNode)</span> </span>&#123;</span><br><span class="line">        MCSNode predecessor = UPDATER.getAndSet(<span class="keyword">this</span>, currentThreadMcsNode);<span class="comment">// step 1</span></span><br><span class="line">        <span class="keyword">if</span> (predecessor != <span class="keyword">null</span>) &#123;</span><br><span class="line">            predecessor.next = currentThreadMcsNode;<span class="comment">// step 2</span></span><br><span class="line"></span><br><span class="line">            <span class="keyword">while</span> (currentThreadMcsNode.isLocked) &#123;<span class="comment">// step 3</span></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">unlock</span><span class="params">(MCSNode currentThreadMcsNode)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (UPDATER.get(<span class="keyword">this</span>) == currentThreadMcsNode) &#123;<span class="comment">// 锁拥有者进行释放锁才有意义</span></span><br><span class="line">            <span class="keyword">if</span> (currentThreadMcsNode.next == <span class="keyword">null</span>) &#123;<span class="comment">// 检查是否有人排在自己后面</span></span><br><span class="line">                <span class="keyword">if</span> (UPDATER.compareAndSet(<span class="keyword">this</span>, currentThreadMcsNode, <span class="keyword">null</span>)) &#123;<span class="comment">// step 4</span></span><br><span class="line">                    <span class="comment">// compareAndSet返回true表示确实没有人排在自己后面</span></span><br><span class="line">                    <span class="keyword">return</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    <span class="comment">// 突然有人排在自己后面了，可能还不知道是谁，下面是等待后续者</span></span><br><span class="line">                    <span class="comment">// 这里之所以要忙等是因为：step 1执行完后，step 2可能还没执行完</span></span><br><span class="line">                    <span class="keyword">while</span> (currentThreadMcsNode.next == <span class="keyword">null</span>) &#123; <span class="comment">// step 5</span></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            currentThreadMcsNode.next.isLocked = <span class="keyword">false</span>;</span><br><span class="line">            currentThreadMcsNode.next = <span class="keyword">null</span>;<span class="comment">// for GC</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="为什么采用CLH"><a href="#为什么采用CLH" class="headerlink" title="为什么采用CLH"></a>为什么采用CLH</h4><p>　　AQS的锁策略采用的CLH而不是MCS，原因是CLH要比MCS<strong>更适合处理取消和超时，即响应中断</strong>。因为CLH锁释放时只需要改变自己的属性，MCS锁释放则需要改变后继节点的属性。</p><p>这需要先理解线程的阻塞和等待的概念</p><p><strong>阻塞：</strong>当一个线程试图获取对象锁（非java.util.concurrent库中的锁，即synchronized），而该锁被其他线程持有，则该线程进入阻塞状态。它的特点是使用简单，由JVM调度器来决定唤醒自己，而不需要由另一个线程来显式唤醒自己，不响应中断。</p><p><strong>等待：</strong>当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断。例如调用：Object.wait()、Thread.join()、LockSupport.park()以及等待Lock或Condition。</p><blockquote><p>  　　虽然synchronized和J.U.C里的Lock都实现锁的功能，但线程进入的状态是不一样的。<strong>synchronized会让线程进入阻塞态</strong>，而J.U.C里的<strong>Lock是用LockSupport.park()/unpark()来实现阻塞/唤醒的，会让线程进入等待态</strong>。但话又说回来，虽然等锁时进入的状态不一样，但被唤醒后又都进入runnable态，从行为效果来看又是一样的。</p></blockquote><h4 id="AQS对CLH的改动"><a href="#AQS对CLH的改动" class="headerlink" title="AQS对CLH的改动"></a>AQS对CLH的改动</h4><h5 id="1、加强对队列的管控"><a href="#1、加强对队列的管控" class="headerlink" title="1、加强对队列的管控"></a>1、加强对队列的管控</h5><p>　　CLH只有一个tail节点指向next节点,抽象出一个队列.</p><p>　　AQS中定义了Node类，每个Node有各自的状态并且维护了一个prev和一个next用以形成队列结构。AQS保存了一个head节点和一个tail节点,可以快速判断队列中是否只有一个节点,减少对内存的操作.</p><h5 id="2、阻塞而不是自旋"><a href="#2、阻塞而不是自旋" class="headerlink" title="2、阻塞而不是自旋"></a>2、阻塞而不是自旋</h5><p>　　CLH是轮训前驱节点的状态进行自旋,而AQS是判断前驱节的状态,然后通过LockSupport.park()和LockSupport.unpark()实现线程的阻塞和释放，该类可以响应中断操作，可以设置超时时间等。此机制与Win32内的“消费事件”机制，Linux NPTL线程库的方式类似</p><h3 id="三、AQS两种模式"><a href="#三、AQS两种模式" class="headerlink" title="三、AQS两种模式"></a>三、AQS两种模式</h3><p>上面简单的描述了AQS的原理：</p><blockquote><p>它是一个队列，线程在获取不到锁的情况下会加入队列排队等待，而在队列中只有头的next结点才能获取锁，执行后出队并唤醒后续线程节点。</p></blockquote><p>总结下其实就是两个动作，<strong>获取锁（acquire）和释放锁(release)</strong>。</p><p>在AQS中提供了两种模式的操作</p><h4 id="1-共享模式-SHARED"><a href="#1-共享模式-SHARED" class="headerlink" title="1.共享模式 SHARED"></a>1.共享模式 SHARED</h4><p>共享模式是指同一时刻可以有多个线程获取锁，经典的使用场景是信号量和读写锁。<br>这种模式下的geteState（）一般是指返回锁剩下的数量</p><h5 id="acquireShared-源码解析"><a href="#acquireShared-源码解析" class="headerlink" title="acquireShared()源码解析"></a>acquireShared()源码解析</h5><p>这里插入一下Node节点的状态，这个状态是下面很多操作的条件，了解这个对源码 理解会清晰很多</p><ul><li><strong>SIGNAL</strong> = -1; //表示这个结点的继任结点被阻塞了，到时需要通知它</li><li><strong>CONDITION</strong> = -2; //表示这个结点在条件队列中，因为等待某个条件而被阻塞</li><li><strong>PROPAGATE</strong> = -3; //使用在共享模式头结点有可能处于这种状态，表示锁的下一次获取可以无条件传播</li><li>0：//新结点会处于这种状态。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//step 1 尝试获取共享锁</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (tryAcquireShared(arg) &lt; <span class="number">0</span>) <span class="comment">//子类实现逻辑，如果剩下的锁数量小于0，当前线程就去队列排队</span></span><br><span class="line">            doAcquireShared(arg);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//step 2 执行入队的操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAcquireShared</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line"><span class="comment">//step 2.1 加入CLH队列，节点模式为共享模式</span></span><br><span class="line">        <span class="keyword">final</span> Node node = addWaiter(Node.SHARED);</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head) &#123;</span><br><span class="line">                <span class="comment">//如果当前节点前驱是头结点，则再次尝试获取共享锁</span></span><br><span class="line">                、、【因为只有head的next节点才有资格去申请锁资源】</span><br><span class="line">                    <span class="keyword">int</span> r = tryAcquireShared(arg);</span><br><span class="line">                    <span class="keyword">if</span> (r &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="comment">//step 3 如果获取锁成功，重新设置头结点[节点出队的操作]并传播r个结点释放锁</span></span><br><span class="line">                        setHeadAndPropagate(node, r);</span><br><span class="line">                        p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                        <span class="keyword">if</span> (interrupted)</span><br><span class="line">                            selfInterrupt();</span><br><span class="line">                        failed = <span class="keyword">false</span>;</span><br><span class="line">                        <span class="keyword">return</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="comment">//根据节点的前驱waitstatus的状态，判断后续节点是否需要挂起，</span></span><br><span class="line">                <span class="comment">//如果前驱的waitstus=-1，则使用LockSupport.park()将当期节点的线程挂起</span></span><br><span class="line">                <span class="comment">//如果前驱的waitstus!=-1，则使用CAS将前驱的waitstus设置为-1，接着loop</span></span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)<span class="comment">//如果异常发生，则根据中断标识来取消获取锁的操作</span></span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">//step 2.1</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addWaiter</span><span class="params">(Node mode)</span> </span>&#123;</span><br><span class="line"><span class="comment">//新建当前线程的节点</span></span><br><span class="line">        Node node = <span class="keyword">new</span> Node(Thread.currentThread(), mode);</span><br><span class="line">        <span class="comment">// 队列中有节点时将节点加入尾部</span></span><br><span class="line">        Node pred = tail;</span><br><span class="line">        <span class="keyword">if</span> (pred != <span class="keyword">null</span>) &#123;</span><br><span class="line">            node.prev = pred;</span><br><span class="line">            <span class="keyword">if</span> (compareAndSetTail(pred, node)) &#123;</span><br><span class="line">                pred.next = node;</span><br><span class="line">                <span class="keyword">return</span> node;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        enq(node); <span class="comment">//队列没有节点时初始化头结点</span></span><br><span class="line">        <span class="keyword">return</span> node;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p><strong>step 2加入队列流程图如下：</strong><br>AQS CLH队列初始状态，head和tail节点都指向mull<br><img src="/img/aqs/aqs_addwaiter_init.png" alt="Image text"><br>加入第一个节点时,head节点初始化new Node(),head.next和tail节点都指向node1<br><img src="/img/aqs/aqs_addwaiter_node1.png" alt="Image text"><br>加入第二个个节点时，node2加入尾部，tail指向他<br><img src="/img/aqs/aqs_addwaiter_node2.png" alt="Image text"></p><p>step 3 <code>重新设置头结点并传播节点，这步是节点唯一的出队方式</code>：将dead的next节点设置为新的head结点，并释放节点里的线程引用，这样下个节点就可以等待获取资源执行线程<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">setHeadAndPropagate</span><span class="params">(Node node, <span class="keyword">int</span> propagate)</span> </span>&#123;</span><br><span class="line">        Node h = head; <span class="comment">// Record old head for check below</span></span><br><span class="line">        setHead(node);<span class="comment">//讲当前节点设置为head节点，且释放线程引用</span></span><br><span class="line">        <span class="comment">//如果</span></span><br><span class="line">        <span class="comment">//1.还有资源可以释放(propagete&gt;0)</span></span><br><span class="line">        <span class="comment">//2.头结点为null</span></span><br><span class="line">        <span class="comment">//3.头结点的状态为-1（singal）或是-3(progate)</span></span><br><span class="line">        <span class="comment">//则开始释放他的下一个节点的线程</span></span><br><span class="line">        <span class="keyword">if</span> (propagate &gt; <span class="number">0</span> || h == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span> ||</span><br><span class="line">            (h = head) == <span class="keyword">null</span> || h.waitStatus &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            Node s = node.next;</span><br><span class="line">            <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.isShared())</span><br><span class="line">                doReleaseShared();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="doReleaseShared"><a href="#doReleaseShared" class="headerlink" title="doReleaseShared()"></a>doReleaseShared()</h5><p>释放共享锁的操作很简单，就只是解除head的next节点的线程阻塞，这样这个节点就可以在上面的step 3中出队<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doReleaseShared</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">            Node h = head;</span><br><span class="line">            <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h != tail) &#123;</span><br><span class="line">                <span class="keyword">int</span> ws = h.waitStatus;</span><br><span class="line">                <span class="keyword">if</span> (ws == Node.SIGNAL) &#123;</span><br><span class="line">                    <span class="keyword">if</span> (!compareAndSetWaitStatus(h, Node.SIGNAL, <span class="number">0</span>))</span><br><span class="line">                        <span class="keyword">continue</span>;            <span class="comment">// loop to recheck cases</span></span><br><span class="line">                    unparkSuccessor(h);<span class="comment">//释放head的next节点的线程</span></span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span> <span class="keyword">if</span> (ws == <span class="number">0</span> &amp;&amp;</span><br><span class="line">                         !compareAndSetWaitStatus(h, <span class="number">0</span>, Node.PROPAGATE))</span><br><span class="line">                    <span class="keyword">continue</span>;                <span class="comment">// loop on failed CAS</span></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (h == head)                   <span class="comment">// loop if head changed</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">unparkSuccessor</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">int</span> ws = node.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &lt; <span class="number">0</span>)</span><br><span class="line">            compareAndSetWaitStatus(node, ws, <span class="number">0</span>);</span><br><span class="line">        Node s = node.next;</span><br><span class="line">        <span class="comment">//这里从tail开始，从后往前找到waitstatus&lt;=0节点</span></span><br><span class="line">        <span class="keyword">if</span> (s == <span class="keyword">null</span> || s.waitStatus &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            s = <span class="keyword">null</span>;</span><br><span class="line">            <span class="keyword">for</span> (Node t = tail; t != <span class="keyword">null</span> &amp;&amp; t != node; t = t.prev)</span><br><span class="line">                <span class="keyword">if</span> (t.waitStatus &lt;= <span class="number">0</span>)</span><br><span class="line">                    s = t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (s != <span class="keyword">null</span>)</span><br><span class="line">            LockSupport.unpark(s.thread);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="2-独占模式-MUTEX"><a href="#2-独占模式-MUTEX" class="headerlink" title="2.独占模式 MUTEX"></a>2.独占模式 MUTEX</h4><p>独占锁看名字就很清晰，同一时刻只有一个线程可以获取它。</p><p>上面分析了共享锁，独占锁就很容易了，因为操作大同小异，只有一点细微的差异。</p><h5 id="acquire"><a href="#acquire" class="headerlink" title="acquire()"></a>acquire()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">``` </span><br><span class="line">先tryacquire判断是都可以获取，获取失败则添加节点到队列尾部（addwaiter（）在前面已经分析了），然后再去获取整个队列</span><br><span class="line">##### acquireQueued()</span><br><span class="line">``` java</span><br><span class="line"><span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">acquireQueued</span><span class="params">(<span class="keyword">final</span> Node node, <span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">boolean</span> failed = <span class="keyword">true</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">boolean</span> interrupted = <span class="keyword">false</span>;</span><br><span class="line">            <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">                <span class="keyword">final</span> Node p = node.predecessor();</span><br><span class="line">                <span class="keyword">if</span> (p == head &amp;&amp; tryAcquire(arg)) &#123;</span><br><span class="line">                <span class="comment">//和共享模式的doAcquireShared基本一致，只是少唤醒后续节点的操作</span></span><br><span class="line">                    setHead(node);</span><br><span class="line">                    p.next = <span class="keyword">null</span>; <span class="comment">// help GC</span></span><br><span class="line">                    failed = <span class="keyword">false</span>;</span><br><span class="line">                    <span class="keyword">return</span> interrupted;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (shouldParkAfterFailedAcquire(p, node) &amp;&amp;</span><br><span class="line">                    parkAndCheckInterrupt())</span><br><span class="line">                    interrupted = <span class="keyword">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (failed)</span><br><span class="line">                cancelAcquire(node);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>　　这段代码是不是和前面的doAcquireShared()基本一样？区别只是少了setHeadAndPropagate(),因为独占锁只有一个锁，管好自己就行了，so easy。然后再看看他的锁释放</p><h5 id="release"><a href="#release" class="headerlink" title="release()"></a>release()</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">release</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">if</span> (tryRelease(arg)) &#123;</span><br><span class="line">           Node h = head;</span><br><span class="line">           <span class="keyword">if</span> (h != <span class="keyword">null</span> &amp;&amp; h.waitStatus != <span class="number">0</span>) <span class="comment">//这种情况只在head有next节点情况才满足</span></span><br><span class="line">               unparkSuccessor(h);</span><br><span class="line">           <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">       &#125;</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>　　锁释放也是简单粗暴，只要满足tryRelease的条件（独占锁一般是看重入的state是否降为0），且头结点的不为nul并且不是刚初始化完成的情况下，直接释放head的next节点线程.</p><p>这里，AQS的最核心的操作（acquire和release）就分析完了。</p><h3 id="四、ConditionObject"><a href="#四、ConditionObject" class="headerlink" title="四、ConditionObject"></a>四、ConditionObject</h3><p>为了提高AQS的易用性，内部还提供了条件锁对象<br>　　可以这样理解，上面的acquire和release相当于synchronizer的monitorenter和monitorexit,这两个方法定义了一个同步区域，而Condition.await()和signal()就相当于Object的wait()和notify()。</p><p>这里顺便复习下Object</p><h4 id="Object的wait-和notify"><a href="#Object的wait-和notify" class="headerlink" title="Object的wait()和notify()"></a>Object的wait()和notify()</h4><ul><li>调用某个对象的wait()方法能让当前线程阻塞，并且当前线程必须拥有此对象的monitor（即锁）</li><li>调用某个对象的notify()方法能够唤醒一个正在等待这个对象的monitor的线程，如果有多个线程都在等待这个对象的monitor，则只能唤醒其中一个线程</li><li>notifyAll()就是唤醒所有等待该对象monitor的线程</li></ul><p>如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。</p><blockquote><p>调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁（Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁）；</p></blockquote><h4 id="Condition的await-和signal"><a href="#Condition的await-和signal" class="headerlink" title="Condition的await()和signal()"></a>Condition的await()和signal()</h4><p>上面已经说了ConditionObject是模拟Object的wait和notify。</p><p>这里先不上源码分析，我们可以先思考下自己会怎么去实现这种效果</p><p><strong>await的功能需求:</strong></p><ul><li>1.首先线程要在获取锁的情况下去await</li><li>2.释放锁，然后将当前线程转为等待态（我们可以用LockSupport挂起线程）</li></ul><p><strong>notify的功能需求:</strong></p><ul><li>1.唤醒等待该Condition对象的某个线程（先不管唤醒是随机还是顺序）</li><li>2.被唤醒的线程重新开始和其他线程竞争，抢占锁资源</li></ul><p>有了前面AQS部分的基础，实现这个的思路还是很简单的：</p><ul><li>1.await将线程转为等待态的部分可以用一个新的CLH队列去实现线程等待。因为同一个对象可能在多个线程中使用await，这样就有多个线程在等待，所以必须有个队列去管理他们。线程在队列等待，直到节点被唤醒</li><li>2.notify唤醒的线程本质上做的也还是一个AQS CLH 队列节点的事，拿到锁就执行，没拿到继续等待</li></ul><p>这样思路简化后ConditionObject其实就做了两件事，await()前线程挂起，包装成一个节点放到一个Condition CLH队列，然后signal()就是将Condition的等待节点出队，然后放在AQS的CLH队列中</p><p>下面可以对照源码验证一下思路</p><h4 id="await"><a href="#await" class="headerlink" title="await()"></a>await()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">await</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();</span><br><span class="line">            Node node = addConditionWaiter(); <span class="comment">//当前线程加入Condition CLH 队列</span></span><br><span class="line">            <span class="keyword">int</span> savedState = fullyRelease(node); <span class="comment">//释放当前线程的锁（并清理重入的标记值）</span></span><br><span class="line">            <span class="keyword">int</span> interruptMode = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">while</span> (!isOnSyncQueue(node)) &#123;<span class="comment">//如果不在AQS CLH队列则直接挂起当前线程，在的话说明已经被唤醒，开始执行业务代码</span></span><br><span class="line">                LockSupport.park(<span class="keyword">this</span>);</span><br><span class="line">                <span class="keyword">if</span> ((interruptMode = checkInterruptWhileWaiting(node)) != <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (acquireQueued(node, savedState) &amp;&amp; interruptMode != THROW_IE)</span><br><span class="line">                interruptMode = REINTERRUPT;</span><br><span class="line">            <span class="keyword">if</span> (node.nextWaiter != <span class="keyword">null</span>) <span class="comment">// clean up if cancelled</span></span><br><span class="line">                unlinkCancelledWaiters();<span class="comment">//清理已经是Cancelled状态的Condition CLH的wait节点</span></span><br><span class="line">            <span class="keyword">if</span> (interruptMode != <span class="number">0</span>)</span><br><span class="line">                reportInterruptAfterWait(interruptMode);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//其实加Condition CLH节点方式和AQS CLH队列加节点的方式差不多，就多了个清理Cancelled态节点的判断和操作</span></span><br><span class="line"><span class="function"><span class="keyword">private</span> Node <span class="title">addConditionWaiter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            Node t = lastWaiter;</span><br><span class="line">            <span class="comment">// If lastWaiter is cancelled, clean out.</span></span><br><span class="line">            <span class="keyword">if</span> (t != <span class="keyword">null</span> &amp;&amp; t.waitStatus != Node.CONDITION) &#123;</span><br><span class="line">                unlinkCancelledWaiters();</span><br><span class="line">                t = lastWaiter;</span><br><span class="line">            &#125;</span><br><span class="line">            Node node = <span class="keyword">new</span> Node(Thread.currentThread(), Node.CONDITION);</span><br><span class="line">            <span class="keyword">if</span> (t == <span class="keyword">null</span>)</span><br><span class="line">                firstWaiter = node;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                t.nextWaiter = node;</span><br><span class="line">            lastWaiter = node;</span><br><span class="line">            <span class="keyword">return</span> node;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><h4 id="signal"><a href="#signal" class="headerlink" title="signal()"></a>signal()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">signal</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">if</span> (!isHeldExclusively())</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IllegalMonitorStateException();</span><br><span class="line">            Node first = firstWaiter;</span><br><span class="line">            <span class="keyword">if</span> (first != <span class="keyword">null</span>)</span><br><span class="line">                doSignal(first);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doSignal</span><span class="params">(Node first)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">do</span> &#123;</span><br><span class="line">                <span class="keyword">if</span> ( (firstWaiter = first.nextWaiter) == <span class="keyword">null</span>)</span><br><span class="line">                    lastWaiter = <span class="keyword">null</span>;</span><br><span class="line">                <span class="comment">//这里和AQS CLH的release稍微不同的是他是从第一个节点开始释放，AQS是释放head的next节点</span></span><br><span class="line">                first.nextWaiter = <span class="keyword">null</span>;</span><br><span class="line">            &#125; <span class="keyword">while</span> (!transferForSignal(first) <span class="comment">//将first节点加入AQS CLH队列</span></span><br><span class="line">                    &amp;&amp; (first = firstWaiter) != <span class="keyword">null</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">final</span> <span class="keyword">boolean</span> <span class="title">transferForSignal</span><span class="params">(Node node)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!compareAndSetWaitStatus(node, Node.CONDITION, <span class="number">0</span>))</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">false</span>;</span><br><span class="line"></span><br><span class="line">        Node p = enq(node); <span class="comment">//节点加入AQS CLH</span></span><br><span class="line">        <span class="keyword">int</span> ws = p.waitStatus;</span><br><span class="line">        <span class="keyword">if</span> (ws &gt; <span class="number">0</span> || !compareAndSetWaitStatus(p, ws, Node.SIGNAL))</span><br><span class="line">            LockSupport.unpark(node.thread);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="五、AQS的响应中断"><a href="#五、AQS的响应中断" class="headerlink" title="五、AQS的响应中断"></a>五、AQS的响应中断</h3><p>其实AQS的响应中断处理还是挺简单的，虽然有很多逻辑去判断中断的状态标识，有些地方还设置了中断状态码去标识。</p><p>这里一句话描述AQS的响应中断：<strong>需要响应中断的就throw InterruptedException,不需要响应中断处理的就进行下中断标识的补充，标记线程被中断过了</strong>。两种情况的后续处理看自己的业务需求了</p><p>比如：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquire</span><span class="params">(<span class="keyword">int</span> arg)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg) &amp;&amp;</span><br><span class="line">            acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class="line">            selfInterrupt();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">selfInterrupt</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        Thread.currentThread().interrupt();<span class="comment">//打个中断标记</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">acquireInterruptibly</span><span class="params">(<span class="keyword">int</span> arg)</span></span></span><br><span class="line"><span class="function">            <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (Thread.interrupted())</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> InterruptedException();<span class="comment">//发现中断标记则清理标记并抛出中断异常</span></span><br><span class="line">        <span class="keyword">if</span> (!tryAcquire(arg))</span><br><span class="line">            doAcquireInterruptibly(arg);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="六、引用"><a href="#六、引用" class="headerlink" title="六、引用"></a>六、引用</h3><ul><li><a href="http://www.cnblogs.com/waterystone/p/4920007.html" target="_blank" rel="noopener">http://www.cnblogs.com/waterystone/p/4920007.html</a></li><li><a href="https://blog.csdn.net/iter_zc/article/details/40373881" target="_blank" rel="noopener">https://blog.csdn.net/iter_zc/article/details/40373881</a> </li></ul>]]></content>
    
    <summary type="html">
    
      摘要,基于CLH的变体队列同步器
    
    </summary>
    
      <category term="j.u.c" scheme="http://yoursite.com/categories/j-u-c/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="j.u.c" scheme="http://yoursite.com/tags/j-u-c/"/>
    
      <category term="tools" scheme="http://yoursite.com/tags/tools/"/>
    
  </entry>
  
  <entry>
    <title>NIO之ByteBuffer与ByteBuf</title>
    <link href="http://yoursite.com/2018/06/13/NIO%E4%B9%8BByteBuffer%E4%B8%8EByteBuf/"/>
    <id>http://yoursite.com/2018/06/13/NIO之ByteBuffer与ByteBuf/</id>
    <published>2018-06-13T02:37:52.000Z</published>
    <updated>2018-07-20T10:14:06.454Z</updated>
    
    <content type="html"><![CDATA[<h3 id="ByteBuffer"><a href="#ByteBuffer" class="headerlink" title="ByteBuffer"></a>ByteBuffer</h3><h4 id="几个重要的变量："><a href="#几个重要的变量：" class="headerlink" title="几个重要的变量："></a>几个重要的变量：</h4><ul><li><strong>position</strong> 当前位置的下标。默认0</li><li><strong>mark</strong> 调用mark()保存的postion，可以提供重复读取的功能。 默认-1，没有被标记</li><li><strong>limit</strong> 在Buffer上进行的<code>读写操作都不能越过这个下标</code>。当写数据到buffer中时，limit一般和capacity相等.当读数据时，limit代表buffer中有效数据的长度。</li><li><strong>capacity</strong> buffer能放置的数据数目（没有说和数组的长度有关系）<blockquote><p>mark &lt;= position &lt;= limit &lt;= capacity</p></blockquote></li></ul><a id="more"></a><h4 id="buf的读写"><a href="#buf的读写" class="headerlink" title="buf的读写"></a>buf的读写</h4><p>jdk的bytebuff 是根据上面几个变量判断读写的范围<br>举个小demo<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ByteBuffer buffer = ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">        String value = <span class="string">"hehe"</span>;</span><br><span class="line">        buffer.put(value.getBytes());</span><br><span class="line">        buffer.flip();<span class="comment">//读写切换</span></span><br><span class="line">        <span class="keyword">byte</span>[] vArray = <span class="keyword">new</span> <span class="keyword">byte</span>[buffer.remaining()];<span class="comment">//获取可读取的字节长度</span></span><br><span class="line">        buffer.get(vArray);<span class="comment">//读取缓存字节数组</span></span><br><span class="line">        System.out.println(<span class="keyword">new</span> String(vArray));</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h5 id="flip"><a href="#flip" class="headerlink" title="flip()"></a>flip()</h5><p>flip()源码，本质其实就是用position和limit确认读取的字节起始和结尾位置，每次切换的时候变更首尾<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">flip</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        limit = position;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><p>flip图示<br><img src="/img/jdk/nio/buf/jdk_nio_buf_flip.png" alt="Image text"></p><h5 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h5><p>看源码很清晰，就是将pos设为0，limit设置为最大长度<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> Buffer <span class="title">clear</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        position = <span class="number">0</span>;</span><br><span class="line">        limit = capacity;</span><br><span class="line">        mark = -<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">`</span><br></pre></td></tr></table></figure></p><h4 id="DirectByteBuffer"><a href="#DirectByteBuffer" class="headerlink" title="DirectByteBuffer"></a>DirectByteBuffer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">DirectByteBuffer(<span class="keyword">int</span> cap) &#123;                   <span class="comment">// package-private</span></span><br><span class="line">       <span class="keyword">super</span>(-<span class="number">1</span>, <span class="number">0</span>, cap, cap);</span><br><span class="line">       <span class="keyword">boolean</span> pa = VM.isDirectMemoryPageAligned();</span><br><span class="line">       <span class="keyword">int</span> ps = Bits.pageSize();</span><br><span class="line">       <span class="keyword">long</span> size = Math.max(<span class="number">1L</span>, (<span class="keyword">long</span>)cap + (pa ? ps : <span class="number">0</span>));</span><br><span class="line">       Bits.reserveMemory(size, cap);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">long</span> base = <span class="number">0</span>;</span><br><span class="line">       <span class="keyword">try</span> &#123;</span><br><span class="line">           base = unsafe.allocateMemory(size);</span><br><span class="line">       &#125; <span class="keyword">catch</span> (OutOfMemoryError x) &#123;</span><br><span class="line">           Bits.unreserveMemory(size, cap);</span><br><span class="line">           <span class="keyword">throw</span> x;</span><br><span class="line">       &#125;</span><br><span class="line">       unsafe.setMemory(base, size, (<span class="keyword">byte</span>) <span class="number">0</span>);</span><br><span class="line">       <span class="keyword">if</span> (pa &amp;&amp; (base % ps != <span class="number">0</span>)) &#123;</span><br><span class="line">           <span class="comment">// Round up to page boundary</span></span><br><span class="line">           address = base + ps - (base &amp; (ps - <span class="number">1</span>));</span><br><span class="line">       &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">           address = base;</span><br><span class="line">       &#125;</span><br><span class="line">       cleaner = Cleaner.create(<span class="keyword">this</span>, <span class="keyword">new</span> Deallocator(base, size, cap));<span class="comment">// step3       att = null;</span></span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这里的Cleaner看源码是继承了幻影引用，为GC提供了帮助<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Cleaner</span> <span class="keyword">extends</span> <span class="title">PhantomReference</span>&lt;<span class="title">Object</span>&gt; </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> ReferenceQueue&lt;Object&gt; dummyQueue = <span class="keyword">new</span> ReferenceQueue();</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> Cleaner first = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Cleaner next = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> Cleaner prev = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> Runnable thunk;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">synchronized</span> Cleaner <span class="title">add</span><span class="params">(Cleaner var0)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (first != <span class="keyword">null</span>) &#123;</span><br><span class="line">            var0.next = first;</span><br><span class="line">            first.prev = var0;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        first = var0;</span><br><span class="line">        <span class="keyword">return</span> var0;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><h3 id="ByteBuf"><a href="#ByteBuf" class="headerlink" title="ByteBuf"></a>ByteBuf</h3><h3 id="引用相关"><a href="#引用相关" class="headerlink" title="引用相关"></a>引用相关</h3><p><a href="https://blog.csdn.net/dfdsggdgg/article/details/51533287" target="_blank" rel="noopener">https://blog.csdn.net/dfdsggdgg/article/details/51533287</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;ByteBuffer&quot;&gt;&lt;a href=&quot;#ByteBuffer&quot; class=&quot;headerlink&quot; title=&quot;ByteBuffer&quot;&gt;&lt;/a&gt;ByteBuffer&lt;/h3&gt;&lt;h4 id=&quot;几个重要的变量：&quot;&gt;&lt;a href=&quot;#几个重要的变量：&quot; class=&quot;headerlink&quot; title=&quot;几个重要的变量：&quot;&gt;&lt;/a&gt;几个重要的变量：&lt;/h4&gt;&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;position&lt;/strong&gt; 当前位置的下标。默认0&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;mark&lt;/strong&gt; 调用mark()保存的postion，可以提供重复读取的功能。 默认-1，没有被标记&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;limit&lt;/strong&gt; 在Buffer上进行的&lt;code&gt;读写操作都不能越过这个下标&lt;/code&gt;。当写数据到buffer中时，limit一般和capacity相等.当读数据时，limit代表buffer中有效数据的长度。&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;capacity&lt;/strong&gt; buffer能放置的数据数目（没有说和数组的长度有关系）&lt;blockquote&gt;
&lt;p&gt;mark &amp;lt;= position &amp;lt;= limit &amp;lt;= capacity&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/li&gt;
&lt;/ul&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://yoursite.com/categories/jdk/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
      <category term="nio" scheme="http://yoursite.com/tags/nio/"/>
    
  </entry>
  
  <entry>
    <title>java IO流总结</title>
    <link href="http://yoursite.com/2018/06/07/java-IO%E6%B5%81%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2018/06/07/java-IO流总结/</id>
    <published>2018-06-07T12:10:52.000Z</published>
    <updated>2018-07-20T07:45:59.480Z</updated>
    
    <content type="html"><![CDATA[<h3 id="java-I-O流"><a href="#java-I-O流" class="headerlink" title="java I/O流"></a>java I/O流</h3><p>jdk提供最底层的api就是InputStream和OutputStream了，所有的流都是基于这两个的实现和封装</p><a id="more"></a><h3 id="InputStream"><a href="#InputStream" class="headerlink" title="InputStream"></a>InputStream</h3><h4 id="read"><a href="#read" class="headerlink" title="read()"></a>read()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException</span></span><br></pre></td></tr></table></figure><p>read提供api给子类实现，定义字节是一个个读取，并规范返回值-1时表示读到末尾</p><h4 id="read-byte-b-int-offset-int-length"><a href="#read-byte-b-int-offset-int-length" class="headerlink" title="read(byte[] b,int offset,int length)"></a>read(byte[] b,int offset,int length)</h4><p>将一定字节读入到btye数组中<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> c = read();</span><br><span class="line">        <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        b[off] = (<span class="keyword">byte</span>)c;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> i = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">for</span> (; i &lt; len ; i++) &#123;</span><br><span class="line">                c = read();</span><br><span class="line">                <span class="keyword">if</span> (c == -<span class="number">1</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                b[off + i] = (<span class="keyword">byte</span>)c;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException ee) &#123;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h4 id="close"><a href="#close" class="headerlink" title="close()"></a>close()</h4><p>定义流的关闭</p><h3 id="BufferedInputStream"><a href="#BufferedInputStream" class="headerlink" title="BufferedInputStream"></a>BufferedInputStream</h3><p>和FileInputStream类似，对InputStream采用了装饰者设计模式，增强一两个方法，本质还是调用InputStream的方法。</p><h4 id="buff"><a href="#buff" class="headerlink" title="buff"></a>buff</h4><p>在内部封装了一个byte[]数组，作为字节流数据的缓冲容器，一次性从输入字节流中读取多个字节的数据放入byte数组。程序读取部分字节的时候直接从byte数组中获取，直到内存中的数据用完再重新从字节流中读取新的字节。<br><strong>缓冲流没有提高源流的读取速度</strong>，因为无论如何读取字节，底层还是使用InputStream的read()一个一个字节读取的。<br>缓冲流之所以提高效率是在需要多次读取同一个数据源的情况下，通过内存缓冲InputStream的数据，减少磁盘io次数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">BufferedInputStream</span><span class="params">(InputStream in, <span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">super</span>(in);</span><br><span class="line">       <span class="keyword">if</span> (size &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">           <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"Buffer size &lt;= 0"</span>);</span><br><span class="line">       &#125;</span><br><span class="line">       buf = <span class="keyword">new</span> <span class="keyword">byte</span>[size];</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>buff有重要的4个变量:</p><ul><li>count 当前buff里面的字节数，默认0</li><li>pos 当前读取字节的游标的位置，默认0</li><li>markpos 标记的pos位置。当调用了mark方法后，会将pos的位置记录到markpos。当调用reset（）功能时，pos=markpos,这样就实现了重复读取数据的功能。默认-1</li><li>marklimit 它的值表示在调用mark方法后reset方法前最多允许读取的字节数（由markLimit和buffer.size中较大的那个决定的），如果超过这个限制，则在调用reset方法时会 报：Reseting to invalid mark 异常 </li></ul><p>字节的读取和刷新依赖上面的变量:</p><ul><li>不考虑markpos<br><img src="/img/jdk/io/stream/buff_input_stream_01.jpg" alt="Image text"></li><li>考虑markpos<br><img src="/img/jdk/io/stream/buff_input_stream_02.jpg" alt="Image text"><h4 id="read-1"><a href="#read-1" class="headerlink" title="read()"></a>read()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            fill();<span class="comment">//如果当前位置等于或超过字节数量，重新填充</span></span><br><span class="line">            <span class="keyword">if</span> (pos &gt;= count)</span><br><span class="line">                <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> getBufIfOpen()[pos++] &amp; <span class="number">0xff</span>;</span><br></pre></td></tr></table></figure></li></ul><p>这里多了个位与操作，0xff是int类型，二进制为0000 0000 0000 0000 0000 0000 1111 1111<br>getBufIfOpen()[pos++]获得是一个byte值，如果是-1的值直接返回就让程序误以为文件已读完，在这里多个位操作是为了解决这个问题。<br>过程如下：<br>byte的-1（最高位表示符号位，以补码的形式表示负数为：1111 1111）</p><p>转换为int之后的二进制1111 1111 1111 1111 1111 1111 1111 1111</p><p>&amp; 0xff之后高位去0</p><p>最后返回的结果是0000 0000 0000 0000 0000 0000 1111 1111, 为int值为256</p><p>其-128~-1被转为int中128~256的正数表示。</p><p>但这样引入了新问题：byte变成了byte,数据的值发生了变化，真正要用读取的数据时是否还能拿到原始的byte。<br>还拿上面那个例子来看:<br>当读取返回一个256时，将其强制类型转换为byte，(byte)256得到byte的-1，因为byte只有8位，当int的高位被丢弃后就只剩下1111 1111，在byte中高位的1表示符号位为负数，最终的结果即是byte的-1；同样byte的-128（1000 0000）被转为int的128（0000 0000 0000 0000 0000 0000 1000 0000），强制类型转换后还原byte的1000 0000</p><h4 id="fill"><a href="#fill" class="headerlink" title="fill()"></a>fill()</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">fill</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">byte</span>[] buffer = getBufIfOpen();</span><br><span class="line">        <span class="keyword">if</span> (markpos &lt; <span class="number">0</span>)</span><br><span class="line">            pos = <span class="number">0</span>;     <span class="comment">//markpos说明没有标记，则直接将pos位置设置为0</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pos &gt;= buffer.length)  <span class="comment">/* no room left in buffer */</span></span><br><span class="line">            <span class="keyword">if</span> (markpos &gt; <span class="number">0</span>) &#123;  <span class="comment">//0-&gt;markpos位置的数据可以丢弃，copy markpos-&gt;pos的数据到新的buff中</span></span><br><span class="line">                <span class="keyword">int</span> sz = pos - markpos;</span><br><span class="line">                System.arraycopy(buffer, markpos, buffer, <span class="number">0</span>, sz);</span><br><span class="line">                pos = sz;</span><br><span class="line">                markpos = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= marklimit) &#123;<span class="comment">//这里markpos&lt;0 说明pos位置超过了marklimit限制，markpos失效了</span></span><br><span class="line">                markpos = -<span class="number">1</span>;   </span><br><span class="line">                pos = <span class="number">0</span>;        </span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span> (buffer.length &gt;= MAX_BUFFER_SIZE) &#123;<span class="comment">//为毛不放前面判断？？？？</span></span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> OutOfMemoryError(<span class="string">"Required array size too large"</span>);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;  <span class="comment">//这里是markpos&lt;0 &amp;&amp; marklimit&gt;buffer.length &amp;&amp; marklimit&gt;pos的情况，说明0-&gt;pos位置的字节都不能丢弃，那咋办，只能扩容数组了</span></span><br><span class="line">                <span class="keyword">int</span> nsz = (pos &lt;= MAX_BUFFER_SIZE - pos) ?</span><br><span class="line">                        pos * <span class="number">2</span> : MAX_BUFFER_SIZE;</span><br><span class="line">                <span class="keyword">if</span> (nsz &gt; marklimit)</span><br><span class="line">                    nsz = marklimit; <span class="comment">//扩容大小取2*pos，MAX_BUFFER_SIZE与marklimit中的最小值</span></span><br><span class="line">                <span class="keyword">byte</span> nbuf[] = <span class="keyword">new</span> <span class="keyword">byte</span>[nsz];</span><br><span class="line">                System.arraycopy(buffer, <span class="number">0</span>, nbuf, <span class="number">0</span>, pos);</span><br><span class="line">                <span class="keyword">if</span> (!bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, nbuf)) &#123;</span><br><span class="line">                <span class="keyword">throw</span> <span class="keyword">new</span> IOException(<span class="string">"Stream closed"</span>);</span><br><span class="line">                    <span class="comment">//这里有个疑问，多线程访问的情况话也是会失败的，为什么只报流关闭？</span></span><br><span class="line">                    <span class="comment">//因为这个是私有方法，而且只会被read()用，而read()是线程安全的，所以fill的方法其实只会在单线程下访问 </span></span><br><span class="line">                    <span class="comment">//而多线程能影响到buffer引用变化的只有close方法                  </span></span><br><span class="line">                &#125;</span><br><span class="line">                buffer = nbuf;</span><br><span class="line">            &#125;</span><br><span class="line">        count = pos; </span><br><span class="line">        <span class="keyword">int</span> n = getInIfOpen().read(buffer, pos, buffer.length - pos);</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">            count = n + pos;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h5 id="close-1"><a href="#close-1" class="headerlink" title="close()"></a>close()</h5><p>流关闭除了调用inputStream的close()外，还讲buff数组设置为null。buff是否为null，这也是前面很多方法判断流是否关闭的原因了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">       <span class="keyword">byte</span>[] buffer;</span><br><span class="line">       <span class="keyword">while</span> ( (buffer = buf) != <span class="keyword">null</span>) &#123;</span><br><span class="line">           <span class="keyword">if</span> (bufUpdater.compareAndSet(<span class="keyword">this</span>, buffer, <span class="keyword">null</span>)) &#123;</span><br><span class="line">               InputStream input = in;</span><br><span class="line">               in = <span class="keyword">null</span>;</span><br><span class="line">               <span class="keyword">if</span> (input != <span class="keyword">null</span>)</span><br><span class="line">                   input.close();</span><br><span class="line">               <span class="keyword">return</span>;</span><br><span class="line">           &#125;</span><br><span class="line">           <span class="comment">// Else retry in case a new buf was CASed in fill()</span></span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><p>这个方法可以在read()在阻塞方法的情况下保证流的关闭，因为不需要获取对象锁。<br>buffer是volatile的，这里用一个局部变量获取，如果volatile buffer变了，这里的局部变量是否会不会变，所以这快多了一个while（(buffer = buf) != null）去判断，保障buffer可以设置成功，关闭流</p><h3 id="ByteArrayInputStream"><a href="#ByteArrayInputStream" class="headerlink" title="ByteArrayInputStream"></a>ByteArrayInputStream</h3><p>ByteArrayInputStream本质就将一个BtyeArray当成一个输入源，看它的构造方法，流的读取操作其实就是数组的读操作，非常简单<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="title">ByteArrayInputStream</span><span class="params">(<span class="keyword">byte</span> buf[])</span> </span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.buf = buf;</span><br><span class="line">        <span class="keyword">this</span>.pos = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">this</span>.count = buf.length;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> (pos &lt; count) ? (buf[pos++] &amp; <span class="number">0xff</span>) : -<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">int</span> <span class="title">read</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (off &lt; <span class="number">0</span> || len &lt; <span class="number">0</span> || len &gt; b.length - off) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (pos &gt;= count) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">int</span> avail = count - pos;</span><br><span class="line">        <span class="keyword">if</span> (len &gt; avail) &#123;</span><br><span class="line">            len = avail;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (len &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        System.arraycopy(buf, pos, b, off, len);</span><br><span class="line">        pos += len;</span><br><span class="line">        <span class="keyword">return</span> len;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure></p><h3 id="OutputStream"><a href="#OutputStream" class="headerlink" title="OutputStream"></a>OutputStream</h3><p>有了前面InputStream的基础，下面的OutputStream就简单很多<br>输出流最重要是两个东西，write(int b)和flush(),和InputStream类似，流是一个一个字节读的，写的时候也是一个个写的。write的int类型b会强制转换成byte类型。<br>另外为什么会有flush这个方法？为了提高io的效率，我们一般是在读取了一定字节数后才开始执行写操作，比如buffedOutputStream，只有在buff数组满了后才会读取下面的字节，相当于写操作被阻塞了，而flush方法就是打破这个阻塞而设立的。执行这个方法就是强制执行写操作，清空缓冲区的字节。<br>所以一般关闭(close)输出流时，应先刷新(flush)换冲的输出流，这样缓冲区的数据也不会丢失。也就是“迫使所有缓冲的输出数据被写出到底层输出流中”</p><h4 id="write-int-b"><a href="#write-int-b" class="headerlink" title="write(int b)"></a>write(int b)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">int</span> b)</span> <span class="keyword">throws</span> IOException</span>;</span><br></pre></td></tr></table></figure><h4 id="write-byte-b-int-off-int-len"><a href="#write-byte-b-int-off-int-len" class="headerlink" title="write(byte b[], int off, int len)"></a>write(byte b[], int off, int len)</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">write</span><span class="params">(<span class="keyword">byte</span> b[], <span class="keyword">int</span> off, <span class="keyword">int</span> len)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (b == <span class="keyword">null</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> NullPointerException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> ((off &lt; <span class="number">0</span>) || (off &gt; b.length) || (len &lt; <span class="number">0</span>) ||</span><br><span class="line">                   ((off + len) &gt; b.length) || ((off + len) &lt; <span class="number">0</span>)) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IndexOutOfBoundsException();</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (len == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; len ; i++) &#123;</span><br><span class="line">            write(b[off + i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h4 id="flush"><a href="#flush" class="headerlink" title="flush"></a>flush</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//BuffedOutputStream的实现</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        flushBuffer();</span><br><span class="line">        out.flush();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/** Flush the internal buffer */</span></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">flushBuffer</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            out.write(buf, <span class="number">0</span>, count);</span><br><span class="line">            count = <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="Closeable、Flushable-interface"><a href="#Closeable、Flushable-interface" class="headerlink" title="Closeable、Flushable  interface"></a>Closeable、Flushable  interface</h3><p>接口都是定义!<br>继承了这些接口的流，都有实现相应的close(),flush()<br>而且在JDK7中新添加的带资源的try语句，提供了对资源的操作</p><ul><li>由带资源的try语句管理的资源必须是实现了AutoCloseable接口的类的对象。</li><li>在try代码中声明的资源被隐式声明为fianl。</li><li>通过使用分号分隔每个声明可以管理多个资源。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">HeheOutputStream</span> <span class="keyword">extends</span> <span class="title">ByteArrayOutputStream</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HeheOutputStream</span><span class="params">(<span class="keyword">int</span> size)</span> </span>&#123;</span><br><span class="line">            <span class="keyword">super</span>(size);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">flush</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hehe flush!"</span>);</span><br><span class="line">            <span class="keyword">super</span>.flush();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">            System.out.println(<span class="string">"hehe close!"</span>);</span><br><span class="line">            <span class="keyword">super</span>.close();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> (HeheOutputStream outputStream = <span class="keyword">new</span> HeheOutputStream(<span class="number">24</span>);) &#123;</span><br><span class="line">            outputStream.write(<span class="string">"hehe"</span>.getBytes(), <span class="number">0</span>, <span class="number">4</span>);</span><br><span class="line">            System.out.println(outputStream);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">   <span class="comment">//hehe</span></span><br><span class="line">  <span class="comment">//hehe close!</span></span><br></pre></td></tr></table></figure></li></ul><p>发现close方法被自动执行了。flush方法还是需要手动调用- -</p><h3 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h3><h4 id="ObjectInputStream-amp-ObjectOutputStream"><a href="#ObjectInputStream-amp-ObjectOutputStream" class="headerlink" title="ObjectInputStream &amp; ObjectOutputStream"></a>ObjectInputStream &amp; ObjectOutputStream</h4><blockquote><p>serialVersionUID 是用于记录class文件的版本信息的，这个数字是JVM通过一个类的类名、成员、包名、工程名算出的一个数字。相当于一个索引，如果反序列化时发现它的UID与在项目的类，直接反序列化成相应的类</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DzzObject</span> <span class="keyword">implements</span> <span class="title">Serializable</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="keyword">long</span> serialVersionUID = -<span class="number">548199098184506173L</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定了UID后，新增这个变量不影响反序列化</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> age;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">long</span> <span class="title">getSerialVersionUID</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> serialVersionUID;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">getName</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> name;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">toString</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> getName() == <span class="keyword">null</span> ? <span class="string">"no name"</span> : getName();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"> DzzObject dzzObject = <span class="keyword">new</span> DzzObject().setName(<span class="string">"dzz"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">input</span><span class="params">()</span> <span class="keyword">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class="line">        ObjectInputStream in = <span class="keyword">new</span> ObjectInputStream(<span class="keyword">new</span> FileInputStream(<span class="string">"D:\\temp\\dzzObject.txt"</span>));</span><br><span class="line">        Object o = in.readObject();</span><br><span class="line">        System.out.println(o);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">output</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        ObjectOutputStream out = <span class="keyword">new</span> ObjectOutputStream(<span class="keyword">new</span> FileOutputStream(<span class="string">"D:\\temp\\dzzObject.txt"</span>));</span><br><span class="line">        out.writeObject(dzzObject);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="引用相关"><a href="#引用相关" class="headerlink" title="引用相关"></a>引用相关</h3><p><a href="https://blog.csdn.net/u014470581/article/details/62229611" target="_blank" rel="noopener">https://blog.csdn.net/u014470581/article/details/62229611</a><br><a href="http://www.importnew.com/21556.html" target="_blank" rel="noopener">http://www.importnew.com/21556.html</a><br><a href="https://my.oschina.net/fhd/blog/344961" target="_blank" rel="noopener">https://my.oschina.net/fhd/blog/344961</a><br><a href="https://blog.csdn.net/bjo2008cn/article/details/53888923" target="_blank" rel="noopener">https://blog.csdn.net/bjo2008cn/article/details/53888923</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;java-I-O流&quot;&gt;&lt;a href=&quot;#java-I-O流&quot; class=&quot;headerlink&quot; title=&quot;java I/O流&quot;&gt;&lt;/a&gt;java I/O流&lt;/h3&gt;&lt;p&gt;jdk提供最底层的api就是InputStream和OutputStream了，所有的流都是基于这两个的实现和封装&lt;/p&gt;
    
    </summary>
    
      <category term="jdk" scheme="http://yoursite.com/categories/jdk/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
      <category term="io" scheme="http://yoursite.com/tags/io/"/>
    
  </entry>
  
  <entry>
    <title>Thread状态详解</title>
    <link href="http://yoursite.com/2018/06/02/Thread%E7%8A%B6%E6%80%81%E8%AF%A6%E8%A7%A3/"/>
    <id>http://yoursite.com/2018/06/02/Thread状态详解/</id>
    <published>2018-06-01T16:11:52.000Z</published>
    <updated>2018-07-14T12:32:41.307Z</updated>
    
    <content type="html"><![CDATA[<h3 id="一、线程状态转换图"><a href="#一、线程状态转换图" class="headerlink" title="一、线程状态转换图"></a>一、线程状态转换图</h3><a id="more"></a><p>别人总结的一张图，画的很清晰<br>　<img src="/img/jdk/lang/thread/thread_state.png" alt="Image text"></p><p>对应Thread.State的几种状态。</p><h3 id="二、线程的几种状态"><a href="#二、线程的几种状态" class="headerlink" title="二、线程的几种状态"></a>二、线程的几种状态</h3><h4 id="NEW"><a href="#NEW" class="headerlink" title="NEW"></a>NEW</h4><p>这个很好理解，就是new Thread（）对象构造函数构造好时的线程状态</p><h4 id="RUNNABLE"><a href="#RUNNABLE" class="headerlink" title="RUNNABLE"></a>RUNNABLE</h4><p>这种状态是线程有执行权，但是没有获取cpu时间片执行的状态，获得时间片是Running状态。看上面的流程图可以知道在4种情况下变成RUNNABLE状态：</p><ul><li>1.调用start()</li><li>2.running的线程调用yield()方法，交出时间片，让CPU去执行其他的线程（只能让拥有相同优先级的线程有获取CPU执行时间的机会，且不会释放锁）</li><li>3.阻塞状态（BLOCKED）结束，准备执行</li><li>4.等待状态结束（WAITING/TIMED_WAITING）,准备执行<h4 id="WAITING-TIMED-WAITING"><a href="#WAITING-TIMED-WAITING" class="headerlink" title="WAITING/TIMED_WAITING"></a>WAITING/TIMED_WAITING</h4>当一个线程等待另一个线程通知调度器一个条件时，该线程进入等待状态。它的特点是需要等待另一个线程显式地唤醒自己，实现灵活，语义更丰富，可响应中断。<br>将线程进入这个状态有几种方式：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        wait(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">wait</span><span class="params">(<span class="keyword">long</span> timeout)</span> <span class="keyword">throws</span> InterruptedException</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">()</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        join(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">synchronized</span> <span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">long</span> millis)</span> <span class="keyword">throws</span> InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">long</span> base = System.currentTimeMillis();</span><br><span class="line">        <span class="keyword">long</span> now = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalArgumentException(<span class="string">"timeout value is negative"</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (millis == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                wait(<span class="number">0</span>);<span class="comment">//可以看到Thread.join()的本质还是Object的wait()           &#125;</span></span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">while</span> (isAlive()) &#123;</span><br><span class="line">                <span class="keyword">long</span> delay = millis - now;</span><br><span class="line">                <span class="keyword">if</span> (delay &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">                wait(delay);</span><br><span class="line">                now = System.currentTimeMillis() - base;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">native</span> <span class="keyword">void</span> <span class="title">park</span><span class="params">(<span class="keyword">boolean</span> var1, <span class="keyword">long</span> var2)</span></span>;<span class="comment">//park不响应中断，只保留中断标识</span></span><br></pre></td></tr></table></figure></li></ul><h5 id="Object-wait-、Thread-join"><a href="#Object-wait-、Thread-join" class="headerlink" title="Object.wait()、Thread.join()"></a>Object.wait()、Thread.join()</h5><p>Thread.join()<code>[本质是Object.wait()]</code><br>如果调用某个对象的wait()方法，当前线程必须拥有这个对象的monitor（即锁），因此调用wait()方法必须在同步块或者同步方法中进行（synchronized块或者synchronized方法）。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">synchronized</span> (object) &#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                object.wait();</span><br><span class="line">                ...</span><br><span class="line">            &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure></p><p>调用某个对象的wait()方法，相当于让当前线程交出此对象的monitor，然后进入等待状态，等待后续再次获得此对象的锁。</p><h5 id="Thread-sleep"><a href="#Thread-sleep" class="headerlink" title="Thread.sleep()"></a>Thread.sleep()</h5><p>Thread类中的sleep方法使当前线程暂停执行一段时间，从而让其他线程有机会继续执行，但它并不释放对象锁.<br>插篇写sleep比较有意思的文章<a href="https://www.cnblogs.com/bamu/archive/2013/03/14/2959663.html" target="_blank" rel="noopener">https://www.cnblogs.com/bamu/archive/2013/03/14/2959663.html</a></p><h5 id="LockSupport-park"><a href="#LockSupport-park" class="headerlink" title="LockSupport.park()"></a>LockSupport.park()</h5><p>LockSupport并不需要获取对象的监视器，本质是使用了Unsafe.park()。</p><p>每次LockSupport.unpark给线程1个“许可”<strong>(最多也只能是1)</strong>。而park是消耗1个并返回，如果没有许可则会阻塞线程，直到线程重新获得许可。</p><p>值得一提的是park/unpark模型真正解耦了线程之间的同步，线程之间不再需要一个Object或者其它变量来存储状态，不再需要关心对方的状态，只关心许可的数量。所以使用起来特别方便</p><h4 id="BLOCKED"><a href="#BLOCKED" class="headerlink" title="BLOCKED"></a>BLOCKED</h4><p>这个状态jdk源码注释其实说的很直接,基本上说就是等待获取synchronized 快或方法的monitor 锁的状态<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">         * Thread state for a thread blocked waiting for a monitor lock.</span></span><br><span class="line"><span class="comment">         * A thread in the blocked state is waiting for a monitor lock</span></span><br><span class="line"><span class="comment">         * to enter a synchronized block/method or</span></span><br><span class="line"><span class="comment">         * reenter a synchronized block/method after calling</span></span><br><span class="line"><span class="comment">         * &#123;<span class="doctag">@link</span> Object#wait() Object.wait&#125;.</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">        BLOCKED,</span><br></pre></td></tr></table></figure></p><h4 id="TERMINATED"><a href="#TERMINATED" class="headerlink" title="TERMINATED"></a>TERMINATED</h4><p>线程执行完毕的状态。【其实这里还待补充，考虑到线程池的线程状态，占坑，后续补上】</p><h3 id="三、线程中断"><a href="#三、线程中断" class="headerlink" title="三、线程中断"></a>三、线程中断</h3><p>如果线程被阻塞或是等待，它便不能核查共享变量，也就不能停止。这在许多情况下会发生，例如调用 Object.wait()、ServerSocket.accept()和DatagramSocket.receive()时，他们都可能永久的阻塞线程。即使发生超时，在超时期满之前持续等待也是不可行和不适当的，所以，要使用某种机制使得线程更早地退出被阻塞/等待的状态。</p><p>一般线程通过中断标识来实现thread的中断，退出阻塞或是等待的状态。</p><h4 id="interrupt"><a href="#interrupt" class="headerlink" title="interrupt"></a>interrupt</h4><p>interrupt()<strong>仅仅是对线程标记了线程的中断状态</strong>，并不能中断线程运行。</p><p>线程只是根据中断状态的标识对线程进行管理，比如线程在等待的时候对线程中断处理：</p><p>有两类waiting状态，对应不同的中断处理</p><ul><li>1.Object.wait()、Thread.join()和Thread.sleep()，会不停轮询线程的中断状态，如果发现被标记了中断状态，则throw InterruptException异常，并会重置线程中断标志位为false。</li><li>2.LockSupport.park() 在park状态中发现被标记了中断状态，则唤醒线程，不会重置中断状态</li></ul><p>可以通过以下三种方式来判断线程中断状态：</p><ul><li><strong>isInterrupted()</strong> 读取线程的中断标志位，并不会重置。</li><li><strong>interrupted()</strong> 读取线程的中断标志位，并会重置为false.</li><li><strong>throw InterruptException</strong> 抛出该异常的同时，会重置中断标志位为false。</li></ul><h3 id="相关引用及参考"><a href="#相关引用及参考" class="headerlink" title="相关引用及参考"></a>相关引用及参考</h3><p><a href="https://blog.csdn.net/hengyunabc/article/details/28126139" target="_blank" rel="noopener">https://blog.csdn.net/hengyunabc/article/details/28126139</a></p>]]></content>
    
    <summary type="html">
    
      摘要,Thread状态
    
    </summary>
    
      <category term="jdk" scheme="http://yoursite.com/categories/jdk/"/>
    
    
      <category term="笔记" scheme="http://yoursite.com/tags/%E7%AC%94%E8%AE%B0/"/>
    
      <category term="jdk" scheme="http://yoursite.com/tags/jdk/"/>
    
      <category term="thread" scheme="http://yoursite.com/tags/thread/"/>
    
  </entry>
  
</feed>
